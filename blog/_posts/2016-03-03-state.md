---
layout: post
title: "React/Redux TodoMVC, Part 3: State"
series: "React/Redux TodoMVC"
seriesTitle: "State"
description: "Adding application state with Redux."
---

Last time we introduced React; this time we'll introduce Redux!

It's time to add application state. How about the TODO items? Seems like a decent place to start.

Before we can add our first piece of application state, though, there's some boilerplate we need to write. It's time to introduce a lot of new concepts, including Redux.

## Actions and State

Actions and state are kind of related. Once you have both actions and state, then you can add actions or state individually. But when you're first starting out, you really have to define actions *and* state.

So, in order to define our list of TODO items (as *state*), we also have to define an action to go along with it. An "Add TODO" action sounds like it would be a great fit!

## Actions

Actions are just plain old objects. Our actions are going to follow the [Flux Standard Action](https://github.com/acdlite/flux-standard-action) model, which means they'll have a `type` property (generally a string, since that makes debugging and serialization easier) and - for successful actions - a `payload` property. There are a couple other properties, but those are for more advanced scenarios; this simple app will only need `type` and `payload`.

Let's define our "Add TODO" action! Well, it'll need a `type` first off. In real-world projects, it's useful to define *all* the action types in a single file. So, that's what I'll do here (in `actionTypes.jsx`):

    export default {
        ADD_TODO: 'ADD_TODO'
    };

Next, the `payload`. The data that travels as "part" of the `ADD_TODO` action is the TODO item itself (a string). So the `payload` can simply be a string in this case.

## Action Creators

Now that we have a good understanding of the structure of our action, we can implement the action creator. There's a helper library called `redux-actions` that minimizes the repetitive code. With that, we can define our `ADD_TODO` action (in `actions/todoActions.jsx`):

    import ActionTypes from '../actionTypes';
    import { createAction } from 'redux-actions';

    export default {
        add: createAction(ActionTypes.ADD_TODO)
    };

This is a bit dense... To clarify, we're creating an object `TodoActions` that has a method `add` on it. This method takes a single parameter, which is the value of the action's `payload`.

So, the line:

        add: createAction(ActionTypes.ADD_TODO)

is really the same as this:

        add: createAction(ActionTypes.ADD_TODO, todoItem => todoItem)

which is the same as this:

        add: todoItem => ({ type: ActionTypes.ADD_TODO, payload: todoItem })

In Redux, an Action Creator is just a function that creates an action.

## State

The next step is to define some application state (our collection of todos), and define how the `ADD_TODO` action affects that state. Presumably, it should just add the new item to our collection.

This is where it gets a bit wild.




[Source code at this revision](https://github.com/StephenCleary/todomvc-react-redux/tree/) - [Live site at this revision](http://htmlpreview.github.io/?https://github.com/StephenCleary/todomvc-react-redux/blob//index.html) (ignore the "startup flicker"; that's just due to the way it's hosted)

[Most current source code](https://github.com/StephenCleary/todomvc-react-redux) - [Most current live site](http://stephencleary.github.io/todomvc-react-redux/)
