<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stephen Cleary (the blog)</title>
    <description>Stephen Cleary's blog: async/await, programming, language design, and other sundry computer science topics.</description>
    <link>https://blog.stephencleary.com/</link>
    <atom:link rel="self" type="application/rss+xml" href="https://blog.stephencleary.com/feed.xml" />
    <atom:link rel="search" type="application/opensearchdescription+xml" href="https://stephencleary.com/opensearch.xml" title="Cleary Search" />
    
      <item>
        <title>Memory-Mapped Files and Overlaid Structs</title>
        <description>&lt;p&gt;It has been a long, long time since I’ve used memory-mapped files - I think the last time was before .NET existed (!). Recently, I had a need to work with memory-mapped files in C#, and I gathered together a few resources that explain how to do it - specifically, how to map a file into memory and then “overlay” a structure on top of that memory. Since it took me a while to figure this out (and I learned about some cool upcoming features along the way), I thought I’d write this up into a proper post or two.&lt;/p&gt;

&lt;h2 id=&quot;memory-mapped-files&quot;&gt;Memory-Mapped Files&lt;/h2&gt;

&lt;p&gt;Memory-mapped files are a pretty cool technique, where instead of reading disk data into memory directly, you can &lt;em&gt;map&lt;/em&gt; it into the memory space of your process very quickly. Once it’s mapped into your process memory, reading from that memory will read from the disk (as necessary), and writing to that memory will write out to the file (eventually). You can do cool things like create a huge file mapping (way larger than your memory), and it will Just Work, paging memory in and out of your process behind the scenes. There’s a ton of information about memory-mapped files out there; if you’re on Windows, I like &lt;a href=&quot;https://www.amazon.com/Windows-Internals-Part-architecture-management/dp/0735684189?crid=1R9XTJDVYVT4R&amp;amp;qid=1695906423&amp;amp;linkCode=ll1&amp;amp;tag=stepheclearys-20&amp;amp;linkId=a9d94c8104abdd7c669e33fd6ea2d430&amp;amp;language=en_US&amp;amp;ref_=as_li_ss_tl&quot; rel=&quot;nofollow&quot;&gt;Windows Internals&lt;/a&gt; - Part 1 covers the memory manager (including memory-mapped files), and Part 2 has a few additional details on how memory-mapped files interact with the cache manager.&lt;/p&gt;

&lt;p&gt;In C#, mapping a file into memory isn’t terribly complex. First, you open the file (i.e., create a &lt;code&gt;FileStream&lt;/code&gt; object). Then, you create a file mapping. Tip on the file mapping: if you’re mapping an existing file, you can pass &lt;code&gt;0&lt;/code&gt; for the file length to just map the entire file. Finally, you create a view on that file mapping - and this is the step that actually maps the file into the memory space for your process. You &lt;em&gt;can&lt;/em&gt; create a view over the entire file, but if you’re dealing with a very large file mapping, it’s common to create partial views as you need them.&lt;/p&gt;

&lt;p&gt;This code will create a new file, a file mapping (specifying 1000 bytes as the length of the file; the file is immediately grown to this size), and a single view over the entire file:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;FileStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&amp;quot;tmp.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FileShare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RandomAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedFile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MemoryMappedFileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandleInheritability&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaveOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateViewAccessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, you have a &lt;code&gt;view&lt;/code&gt;, which is a handle (actually a pointer) to the part of your process’ memory that actually represents the file contents. What’s really nice about this code is that it’s portable; the same code works on Linux and Windows (and presumably Mac and mobile platforms, though I haven’t tried those). However, pointers aren’t a great interface, especially in a managed language like C#. &lt;code&gt;MemoryMappedViewAccessor&lt;/code&gt; has a bunch of… well… &lt;em&gt;awkward&lt;/em&gt; methods that are essentially “read a signed 16-bit integer at this offset”, “write an unsigned 32-bit integer at this offset”, etc. You can also copy a struct into and out of the view, but I don’t want to go through the trouble of doing a file mapping just to turn around and serialize a struct anyway.&lt;/p&gt;

&lt;p&gt;For convenience, unmanaged languages commonly overlay a structure onto the mapped memory. This approach allows you to define the file structure as an actual &lt;code&gt;struct&lt;/code&gt; and then read/write fields in that struct instead of serializing values to memory or view offsets. “Overlapped structures” might be a more common term than “overlaid structures”, but I want to avoid any confusion with &lt;code&gt;OVERLAPPED&lt;/code&gt;, so I’m using the term “overlaid structures” in these posts.&lt;/p&gt;

&lt;p&gt;If you’re in an unmanaged language like C++, you can just &lt;code&gt;reinterpret_cast&lt;/code&gt; your file mapping view pointer to a structure pointer, and that’s it: you’ve got a struct at the same memory address as your file view! I found that there was much less information about overlaying structs in C#, though. So, let’s see how to do the same thing in C#!&lt;/p&gt;

&lt;h2 id=&quot;overlaid-structs&quot;&gt;Overlaid Structs&lt;/h2&gt;

&lt;p&gt;After a bit of experimentation, this is what I ended up with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Overlay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDisposable&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SafeMemoryMappedViewHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AcquirePointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SafeMemoryMappedViewHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleasePointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is an &lt;code&gt;unsafe&lt;/code&gt; type, but ideally this is the only place where &lt;code&gt;unsafe&lt;/code&gt; is necessary.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Overlay&lt;/code&gt; is mainly just a pointer - the pointer to the view of the file that has been mapped into your process’ memory. It also has a &lt;code&gt;MemoryMappedViewAccessor&lt;/code&gt; member, but that’s just used to free the pointer when the &lt;code&gt;Overlay&lt;/code&gt; instance is disposed.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Overlay&lt;/code&gt; has a single notable member: &lt;code&gt;As&amp;lt;T&amp;gt;()&lt;/code&gt;, which allows you to get a reference to a struct that overlays the mapped memory view.&lt;/p&gt;

&lt;div class=&quot;alert alert-info&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-info-circle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;On Windows (at least), the &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt; handle actually &lt;em&gt;is&lt;/em&gt; a pointer, and the &lt;code&gt;AcquirePointer&lt;/code&gt; and &lt;code&gt;ReleasePointer&lt;/code&gt; calls increment and decrement a reference counter for that handle. &lt;code&gt;Overlay&lt;/code&gt; could be designed very differently (and more efficiently) if it cast the &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt; handle value to a pointer.&lt;/p&gt;

  &lt;p&gt;However, on other platforms, I’m not sure if &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt; is actually a pointer or not, so I’ve stuck with this safer implementation just to make sure the code is portable.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;If you are OK with assuming &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt; is a pointer, you can use this instead of &lt;code&gt;Overlay&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemoryMappedViewAccessorExtensions&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SafeMemoryMappedViewHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DangerousGetHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ToPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a fair amount of “unsafe” and “dangerous” in that code, though, and it also makes some implementation assumptions (specifically, that &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt;’s handle is an actual &lt;em&gt;pointer to memory&lt;/em&gt;). So, for safety, I’m just sticking with &lt;code&gt;Overlay&lt;/code&gt; with its explicit &lt;code&gt;AcquirePointer&lt;/code&gt; and &lt;code&gt;ReleasePointer&lt;/code&gt; calls.&lt;/p&gt;

&lt;h2 id=&quot;using-overlay&quot;&gt;Using Overlay&lt;/h2&gt;

&lt;p&gt;First, define your &lt;code&gt;struct&lt;/code&gt; type, keeping in mind that the in-memory layout (including packing/padding) must reflect the on-disk file structure. Then, you can map a file just like the above code, create an &lt;code&gt;Overlay&lt;/code&gt; type, and acquire a struct reference. At that point, you can read or write the struct as desired.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;First&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;FileStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&amp;quot;tmp.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FileShare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RandomAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedFile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MemoryMappedFileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandleInheritability&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaveOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateViewAccessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Overlay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;First&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Run the code above (works in LINQPad!), and you’ll end up with a &lt;code&gt;tmp.dat&lt;/code&gt; file 1000 bytes long, with the first four bytes having the value of &lt;code&gt;First&lt;/code&gt; (1) and the second four bytes having the value of &lt;code&gt;Second&lt;/code&gt; (2). Note that since you’re reading/writing structures in memory, whatever endianness your machine is will determine the endianness of the binary file. Go ahead and pop it open in a hex editor (there’s an online one called &lt;a href=&quot;https://hexed.it/&quot;&gt;HexEd.it&lt;/a&gt;), and take a look at the binary file itself.&lt;/p&gt;

&lt;h2 id=&quot;endianness&quot;&gt;Endianness&lt;/h2&gt;

&lt;p&gt;If you’re working with portable file formats, handling endianness is a necessity. Values in files on disk must be little-endian or big-endian, regardless of what processor happens to be reading or writing them. I recommend handling the differences in code with helpers, like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OverlayHelpers&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReadBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;BitConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLittleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryPrimitives&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseEndianness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WriteBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLittleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryPrimitives&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseEndianness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReadLittleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;BitConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLittleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryPrimitives&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseEndianness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WriteLittleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLittleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryPrimitives&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseEndianness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The helpers above let you read/write big- or little-endian values, regardless of the endianness of the current machine. They can be used in your structure definitions as such:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Layout&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Convenience accessors&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;First&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverlayHelpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverlayHelpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverlayHelpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverlayHelpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now the same program as above will always write the “first” and “second” fields as 32-bit signed big-endian values:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// (this is the same code as above)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;FileStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&amp;quot;tmp.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FileShare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RandomAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedFile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MemoryMappedFileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandleInheritability&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaveOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateViewAccessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Overlay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;First&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, the code is completely portable: any .NET runtime that supports memory-mapped files (which AFAIK is all of them) will run this code, giving you the ability to define portable binary file formats using overlaid structures.&lt;/p&gt;

&lt;h2 id=&quot;a-word-of-warning-alignment&quot;&gt;A Word of Warning: Alignment&lt;/h2&gt;

&lt;p&gt;Since you’re overlaying structures directly into memory addresses, you have to handle all the alignment requirements yourself. Some more common architectures such as x86/x64 don’t care about alignment and allow you to, e.g., define an &lt;code&gt;int&lt;/code&gt; field at an offset of &lt;code&gt;1&lt;/code&gt;. Other architectures do not allow unaligned access at all.&lt;/p&gt;

&lt;p&gt;As a general guideline, align your structure members by their own size. E.g., an &lt;code&gt;int&lt;/code&gt; is 4 bytes, so it should be aligned on a 4-byte boundary. Put another way, the offset of an &lt;code&gt;int&lt;/code&gt; field from the beginning of the &lt;code&gt;struct&lt;/code&gt; should be evenly divisible by 4. Same for other types: &lt;code&gt;long&lt;/code&gt; should be aligned on an 8-byte boundary, while &lt;code&gt;byte&lt;/code&gt; should be aligned on a 1-byte boundary (i.e., anywhere).&lt;/p&gt;

&lt;h2 id=&quot;a-word-of-warning-exceptions&quot;&gt;A Word of Warning: Exceptions&lt;/h2&gt;

&lt;p&gt;Memory mapped files give you one kind of convenience by mapping files into memory, but the counterpoint is that I/O exceptions may not happen exactly when you expect them to.&lt;/p&gt;

&lt;p&gt;When reading a file using normal I/O calls, if the read fails, then it fails right at that time. When using memory-mapped files, reads &lt;em&gt;from memory&lt;/em&gt; may cause an I/O exception. This is true even if a previous read from that same memory succeeded.&lt;/p&gt;

&lt;p&gt;Similarly, if you write to a file using normal I/O calls, any failures are reported immediately. With memory-mapped files, &lt;em&gt;memory&lt;/em&gt; writes may cause an I/O exception. And since memory-mapped files are lazily flushed to disk, I/O exceptions may be delayed until the view is flushed (during disposal).&lt;/p&gt;

&lt;h2 id=&quot;next-time&quot;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;I hope this has been helpful! If anyone out there knows a way to eliminate the &lt;code&gt;unsafe&lt;/code&gt; code in &lt;code&gt;Overlay&lt;/code&gt;, I’d love to hear it!&lt;/p&gt;

&lt;p&gt;Next time I’m planning to write a bit about overlaying structures with holes in them, which is a useful technique when you have “header” or “container” structures that wrap other structures possibly of different types.&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Sep 2023 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2023/09/memory-mapped-files-overlaid-structs.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2023/09/memory-mapped-files-overlaid-structs.html</guid>
      </item>
    
      <item>
        <title>Grounded ChatGPT</title>
        <description>&lt;p&gt;So, there’s this thing you may have heard of called ChatGPT. A lot of people (myself included) have thought “OK, nice toy. It’s pretty good at producing human-sounding text. But I want to run it &lt;em&gt;on my own data&lt;/em&gt; without becoming a data scientist and spending a few hundred thousand dollars in training costs.”&lt;/p&gt;

&lt;p&gt;Then someone pointed out to me there’s already a technique for this called Retrieval Augmented Generation, and in fact there’s some &lt;a href=&quot;https://github.com/Azure-Samples/azure-search-openai-demo&quot;&gt;sample code right there&lt;/a&gt; showing how to do it.&lt;/p&gt;

&lt;h2 id=&quot;retrieval-augmented-generation&quot;&gt;Retrieval Augmented Generation&lt;/h2&gt;

&lt;p&gt;To save you a Google search (or ChatGPT query?), here’s my super-simple description of this technique: when the user asks a question, instead of just giving it to ChatGPT directly, first do a &lt;em&gt;search&lt;/em&gt; for that question over your own data, and combine the search results &lt;em&gt;along with&lt;/em&gt; the user’s question as the ChatGPT input.&lt;/p&gt;

&lt;p&gt;This technique “grounds” ChatGPT, giving it your own data alongside the user’s question. If you structure your input properly, you can influence ChatGPT to produce relevant results, even including source references. With this technique, ChatGPT is able to produce much better results, without the need for training or even fine-tuning the model itself.&lt;/p&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample Code&lt;/h2&gt;

&lt;p&gt;The official sample referenced above is in Python. And I love Python. As a language, I mean. But it’s been… um… 25 years or so since I’ve used it. Definitely rusty. So I decided to write my own sample (heavily influenced by the official one) in C#. And using local Docker containers as much as possible instead of creating a bunch of Azure resources.&lt;/p&gt;

&lt;p&gt;You can find my &lt;a href=&quot;https://github.com/StephenCleary/grounded-chatgpt&quot;&gt;C# Retrieval Augmented Generation code on GitHub&lt;/a&gt;. It’s not production-ready, but it gets the general point across. You can use it pretty easily to “teach” ChatGPT about modern events or your own custom data. It uses Elasticsearch and Seq (both in local Docker containers), preserving its data in local Docker volumes. And it has exhaustive logging out of the box, so you can always review what APIs were called and how exactly they work. My code does use the Azure OpenAI API to talk to ChatGPT, but everything else is in local Docker containers.&lt;/p&gt;

&lt;h2 id=&quot;more-implementation-details&quot;&gt;More Implementation Details&lt;/h2&gt;

&lt;p&gt;When you use this sample code to do a retrieval-augmented generation, what actually happens is this:&lt;/p&gt;

&lt;p&gt;The user’s question is sent to ChatGPT to extract search keywords, using this template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Below is a question asked by the user that needs to be answered by searching.
Generate a search query based on names and concepts extracted from the question.

### Question:
{question}

### Search query:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ChatGPT is pretty good at generating a search query from a user question; I set the &lt;code&gt;temperature&lt;/code&gt; to zero to ensure there’s no randomness in this call.&lt;/p&gt;

&lt;p&gt;Next, this ChatGPT response is sent to Elasticsearch (just as a &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html&quot;&gt;simple query string&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The results of the Elasticsearch search are then formatted and injected into a ChatGPT prompt that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Answer the following question. You may include multiple answers, but each answer may only use the data provided in the References below.
Each Reference has a number followed by tab and then its data.
Use square brakets to indicate which Reference was used, e.g. [7]
Don't combine References; list each Reference separately, e.g. [1][2]
If you cannot answer using the References below, say you don't know. Only provide answers that include at least one Reference name.
If asking a clarifying question to the user would help, ask the question.
Do not comment on unused References.

### References:
{sources}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result is then post-processed to extract the quoted references and change them to hyperlinks.&lt;/p&gt;

&lt;h2 id=&quot;have-fun&quot;&gt;Have Fun!&lt;/h2&gt;

&lt;p&gt;I’ve been pretty pleased with the results, even though I’m using very simplistic source processing, and a lexical search instead of a more proper semantic/vector search. Even with those limitations, the results are pretty impressive!&lt;/p&gt;

&lt;p&gt;That’s all I have to say for now. Have fun!&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2023/05/grounded-chatgpt.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2023/05/grounded-chatgpt.html</guid>
      </item>
    
      <item>
        <title>Modern C# Techniques, Part 3: Generic Code Generation</title>
        <description>&lt;p&gt;This technique really excites me! We’re in for a good ride today…&lt;/p&gt;

&lt;h2 id=&quot;c-templates-and-code-generation&quot;&gt;C++ Templates and Code Generation&lt;/h2&gt;

&lt;p&gt;Before we take a look at C# generics, first I’ll take a brief look at how C++ templates are used for code generation.&lt;/p&gt;

&lt;p&gt;Templates (and generics) are both forms of polymorphic functions; that is, you define one type (or method) that takes a type parameter, and the generic type/method is able to change its behavior based on the type passed in.&lt;/p&gt;

&lt;p&gt;C++ templates are purely a compile-time construct; they instruct the compiler how to generate the code for the template type/method. Specifically, the compiler performs a transformation called &lt;a href=&quot;https://en.wikipedia.org/wiki/Monomorphization&quot;&gt;monomorphization&lt;/a&gt;; for each of the template arguments actually passed to the type/method, the compiler generates a new copy of the type/method specifically for that template argument.&lt;/p&gt;

&lt;p&gt;Monomorphization is what enables C++ templates to be used as code generators.&lt;/p&gt;

&lt;h2 id=&quot;c-generics&quot;&gt;C# Generics&lt;/h2&gt;

&lt;p&gt;C# generics are a run-time construct; the compiler actually outputs the generic type/method itself into the IL (intermediate language). At runtime, the implementation of a generic type/method is shared between the generic arguments.&lt;/p&gt;

&lt;p&gt;In other words, C# generics do &lt;em&gt;not&lt;/em&gt; undergo monomorphization… except…&lt;/p&gt;

&lt;h3 id=&quot;generics-and-value-types&quot;&gt;Generics and Value Types&lt;/h3&gt;

&lt;p&gt;…except when used with value types!&lt;/p&gt;

&lt;p&gt;C# generics do &lt;em&gt;not&lt;/em&gt; undergo monomorphization for reference types; there’s only one copy of the type/method implementation that is shared between all reference types. However, C# generics &lt;em&gt;do&lt;/em&gt; undergo monomorphization for value types!&lt;/p&gt;

&lt;p&gt;This makes sense; if a method &lt;code&gt;Something&amp;lt;T&amp;gt;&lt;/code&gt; defines a local variable &lt;code&gt;T value;&lt;/code&gt;, the compiler needs to know how big that &lt;code&gt;T&lt;/code&gt; is. The size of a reference is the same regardless of the type being referred to, but the size of value type values can vary.&lt;/p&gt;

&lt;p&gt;So, it turns out that C# generics &lt;em&gt;do&lt;/em&gt; have monomorphization. They just don’t do it for &lt;em&gt;all&lt;/em&gt; generic arguments, only the ones that are value types. And monomorphization isn’t done by the C# compiler; it’s done by the JIT compiler (at runtime).&lt;/p&gt;

&lt;h3 id=&quot;generics-and-constrained-value-types&quot;&gt;Generics and Constrained Value Types&lt;/h3&gt;

&lt;p&gt;Monomorphization is fine for &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; and friends, which don’t actually &lt;em&gt;do&lt;/em&gt; anything with the &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For code generation, though, monomorphization is most useful if you also constrain the generics to a specific interface. A simple (and rather silly) example will make this more clear:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;interface ISample
{
  int Setting { get; }
}

void Function&amp;lt;T&amp;gt;()
    where T : struct, ISample
{
  if (default(T).Setting == 13)
    Console.WriteLine(&quot;Ah, my favorite number!&quot;);
  else
    Console.WriteLine($&quot;You passed {default(T).Setting}.&quot;);
}

readonly struct Sample7 : ISample
{
  public int Setting =&amp;gt; 7;
}

readonly struct Sample13 : ISample
{
  public int Setting =&amp;gt; 13;
}

Function&amp;lt;Sample7&amp;gt;();
Function&amp;lt;Sample13&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The C# compiler just treats &lt;code&gt;Function&lt;/code&gt; like an ordinary generic function. The JIT compiler will create &lt;em&gt;two separate copies&lt;/em&gt; of &lt;code&gt;Function&lt;/code&gt;; because &lt;code&gt;Sample7&lt;/code&gt; and &lt;code&gt;Sample13&lt;/code&gt; are both value types, monomorphization occurs and the JIT compiler generates &lt;em&gt;two&lt;/em&gt; copies of the method. In both copies, the &lt;code&gt;default(T).Setting&lt;/code&gt; code is emmitted as a constrained virtual call.&lt;/p&gt;

&lt;p&gt;Then, each copy of the method has a high likelihood of being optimized. After all, the compiler knows the type of &lt;code&gt;T&lt;/code&gt; for each copy. When it optimizes &lt;code&gt;Function&amp;lt;Sample7&amp;gt;&lt;/code&gt;, it &lt;em&gt;knows&lt;/em&gt; that the &lt;code&gt;default(T).Setting&lt;/code&gt; is calling the &lt;code&gt;ISample.get_Setting&lt;/code&gt; method on the &lt;code&gt;Sample7&lt;/code&gt; type. The &lt;code&gt;Sample7&lt;/code&gt; implementation of &lt;code&gt;ISample.Setting&lt;/code&gt; is trivial and is likely going to be inlined, which means that the &lt;code&gt;if&lt;/code&gt; branch can be precomputed. It is extremely likely that both copies of &lt;code&gt;Function&amp;lt;T&amp;gt;&lt;/code&gt; only end up having a single &lt;code&gt;Console.WriteLine&lt;/code&gt; call, without any &lt;code&gt;if&lt;/code&gt; statement at all!&lt;/p&gt;

&lt;p&gt;At this point, we have real code generation using C# generics!&lt;/p&gt;

&lt;h3 id=&quot;generics-and-constrained-value-types-with-static-abstract-interface-methods&quot;&gt;Generics and Constrained Value Types with Static Abstract Interface Methods&lt;/h3&gt;

&lt;p&gt;Static abstract interface methods allow us to clean this up even a bit more. Instead of defining &lt;code&gt;Setting&lt;/code&gt; as an instance method, it can now be a static method, as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;interface ISample
{
  static abstract int Setting { get; }
}

void Function&amp;lt;T&amp;gt;()
    where T : struct, ISample
{
  if (T.Setting == 13)
    Console.WriteLine(&quot;Ah, my favorite number!&quot;);
  else
    Console.WriteLine($&quot;You passed {T.Setting}.&quot;);
}

readonly struct Sample7 : ISample
{
  public static int Setting =&amp;gt; 7;
}

readonly struct Sample13 : ISample
{
  public static int Setting =&amp;gt; 13;
}

Function&amp;lt;Sample7&amp;gt;();
Function&amp;lt;Sample13&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now there’s no need for a &lt;code&gt;default(T)&lt;/code&gt; value inside &lt;code&gt;Function&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;warnings-and-limitations&quot;&gt;Warnings and Limitations&lt;/h2&gt;

&lt;p&gt;By using C# generics with value types, we can ensure monomorphization takes place; however, the rest of the behavior is not guaranteed.&lt;/p&gt;

&lt;h3 id=&quot;no-guarantees&quot;&gt;No Guarantees&lt;/h3&gt;

&lt;p&gt;The JIT compiler doesn’t actually &lt;em&gt;guarantee&lt;/em&gt; that any particular methods are inlined, or that any kind of optimization takes place (e.g., removing the &lt;code&gt;if&lt;/code&gt; statement in our example). It’s reasonable to assume that &lt;em&gt;some&lt;/em&gt; optimization will take place, and with modern tiered optimization, you can also expect that the method will become &lt;em&gt;more&lt;/em&gt; optimized if it is called a lot.&lt;/p&gt;

&lt;p&gt;With C++ templates (and other compile-time-only monomorphization systems), you can &lt;em&gt;know&lt;/em&gt; that the resulting code will be fully optimized. With C# generics, the optimization happens at runtime, so the runtime has to balance between executing the code &lt;em&gt;now&lt;/em&gt; and speeding it up for &lt;em&gt;later&lt;/em&gt;. At the end of the day, the best you can do is hope.&lt;/p&gt;

&lt;h3 id=&quot;limited-to-interfaces&quot;&gt;Limited to Interfaces&lt;/h3&gt;

&lt;p&gt;When doing this kind of code generation, you’re limited to only what can be expressed as interface members. You can define methods and properties, but not &lt;code&gt;const&lt;/code&gt; values or nested types. It’s not a &lt;em&gt;complete&lt;/em&gt; code generation solution like C++ templates, but it’s certainly useful nonetheless.&lt;/p&gt;

&lt;h2 id=&quot;applications&quot;&gt;Applications&lt;/h2&gt;

&lt;h3 id=&quot;more-efficient-general-algortihms&quot;&gt;More Efficient General Algortihms&lt;/h3&gt;

&lt;p&gt;There are some algorithms that take parameters that often don’t change for a given program. To take an example I’m familiar with, CRC32 hashes are actually a &lt;em&gt;class&lt;/em&gt; of hash algorithms with different values for polynomials, initializers, and a few other parameters. Usually, a program that uses a CRC32 hash only uses &lt;em&gt;one&lt;/em&gt; of these algorithms (one specific polynomial with a specific initializer value, etc). If the CRC32 implementation uses code generation, that will allow the JIT compiler to optimize just for that specific CRC32 hash algorithm.&lt;/p&gt;

&lt;h3 id=&quot;more-general-algortihms&quot;&gt;More General Algortihms&lt;/h3&gt;

&lt;p&gt;It’s also possible to make one algorithm even more generic, especially due to the static interface methods. For a similar example to the above, CRC16 is &lt;em&gt;another&lt;/em&gt; class of hash algorithms that is practically the same as CRC32 except it uses 16-bit integers instead of 32-bit integers. Static interface methods would allow a single unified “CRC” algorithm that can handle &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members?WT.mc_id=DT-MVP-5000058#generic-math&quot;&gt;any numeric type with generic math constraints&lt;/a&gt;. So our CRC32 and CRC16 implementations can be combined.&lt;/p&gt;

&lt;h3 id=&quot;replacing-constant-arguments&quot;&gt;Replacing Constant Arguments&lt;/h3&gt;

&lt;p&gt;There are a few situations in code where certain method arguments are always constant values. This is usually an indication that the method should be split into two methods, but sometimes there are maintenance concerns that are sufficiently strong, keeping the methods as a single implementation.&lt;/p&gt;

&lt;p&gt;The example that I’m most familiar with here is the &lt;a href=&quot;https://learn.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development?WT.mc_id=DT-MVP-5000058#the-flag-argument-hack&quot;&gt;boolean argument hack&lt;/a&gt; for providing both synchronous and asynchronous versions of a method, which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;private async Task&amp;lt;string&amp;gt; GetCoreAsync(bool sync)
{
  if (sync)
    Thread.Sleep(TimeSpan.FromSeconds(1));
  else
    await Task.Delay(TimeSpan.FromSeconds(1));
  return &quot;Hi!&quot;;
}

public string Get() =&amp;gt; GetCoreAsync(sync: true).GetAwaiter().GetResult();
public Task&amp;lt;string&amp;gt; GetAsync() =&amp;gt; GetCoreAsync(sync: false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above, &lt;code&gt;GetCoreAsync&lt;/code&gt; has a &lt;code&gt;sync&lt;/code&gt; argument that is &lt;em&gt;always&lt;/em&gt; a constant. Really, it &lt;em&gt;should&lt;/em&gt; be two different methods, but if we pretend that &lt;code&gt;GetCoreAsync&lt;/code&gt; is much longer and more complex, then making it two different methods does cause a maintenance burden.&lt;/p&gt;

&lt;p&gt;So, let’s use generic code generation to &lt;em&gt;generate&lt;/em&gt; two different methods!&lt;/p&gt;

&lt;p&gt;First, we’d extract the code differences (&lt;code&gt;Thread.Sleep&lt;/code&gt; vs &lt;code&gt;Task.Delay&lt;/code&gt;). These are going to need a definition in our interface, and they’ll be implemented by each value type. Since we’re talking about code that may be synchronous or asynchronous, we’ll use value tasks as the return type. (Reminder: any time you have a method whose implementation &lt;em&gt;may&lt;/em&gt; be asynchronous, then it should have an asynchronous signature). Then, &lt;code&gt;GetCoreAsync&lt;/code&gt; can just invoke those interface methods. We end up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;private interface IDelay
{
  static abstract ValueTask DelayAsync(TimeSpan delay);
}

private readonly struct SynchronousDelay : IDelay
{
  static ValueTask DelayAsync(TimeSpan delay)
  {
    Thread.Sleep(delay);
    return new();
  }
}

private readonly struct AsynchronousDelay : IDelay
{
  static async ValueTask DelayAsync(TimeSpan delay) =&amp;gt; await Task.Delay(delay);
}

private async Task&amp;lt;string&amp;gt; GetCoreAsync&amp;lt;TDelay&amp;gt;()
    where TDelay: struct, IDelay
{
  await TDelay.DelayAsync(TimeSpan.FromSeconds(1));
  return &quot;Hi!&quot;;
}

public string Get() =&amp;gt; GetCoreAsync&amp;lt;SynchronousDelay&amp;gt;().GetAwaiter().GetResult();
public Task&amp;lt;string&amp;gt; GetAsync() =&amp;gt; GetCoreAsync&amp;lt;AsynchronousDelay&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The core implementation (&lt;code&gt;GetCoreAsync&lt;/code&gt;) is simplified and is more obviously correct. The public interface (&lt;code&gt;Get&lt;/code&gt; and &lt;code&gt;GetAsync&lt;/code&gt;) didn’t change at all. And at runtime, if only one path is used, then only one path will be JITted. If both paths are used, then two copies of &lt;code&gt;GetCoreAsync&lt;/code&gt; are created by the JITter, each one optimized for its own situation (asynchronous or synchronous). This is a particularly useful technique for libraries, which may need to provide both forms of methods, but have a high likelihood of only one of them being used.&lt;/p&gt;

&lt;p&gt;Stephen Toub discusses how the BCL uses this technique &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/?WT.mc_id=DT-MVP-5000058#:~:text=One%20final%20change%20related%20to%20reading%20and%20writing%20performance&quot;&gt;in a recent blog post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Generic code generation provides a limited form of code generation in C#, because value types cause monomorphization. Static interface members provide an even nicer way to do generic code generation.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/10/modern-csharp-techniques-3-generic-code-generation.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/10/modern-csharp-techniques-3-generic-code-generation.html</guid>
      </item>
    
      <item>
        <title>Modern C# Techniques, Part 2: Value Records</title>
        <description>&lt;p&gt;Today I’ll cover another technique for modern C# that isn’t exactly &lt;em&gt;new&lt;/em&gt;, but which the language supports much better than it used to.&lt;/p&gt;

&lt;p&gt;I’m calling today’s technique Value Records, which are a form of the more general “value object” pattern that is specific to modern C#. But before we dive into the solution, let’s look at the problem.&lt;/p&gt;

&lt;h2 id=&quot;primitive-obsession&quot;&gt;Primitive Obsession&lt;/h2&gt;

&lt;p&gt;The name of the antipattern we’re trying to remove is Primitive Obsession. This is a highly searchable term with some great descriptions out there.&lt;/p&gt;

&lt;p&gt;Essentially, Primitive Obsession is when a developer (over)uses primitives (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;Guid&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, etc) to represent business or domain concepts. One classic example is entity ids. There are a couple of problems with using primitives like this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The primitives are not type-safe. In other words, it’s easy to accidentally pass a &lt;code&gt;customerId&lt;/code&gt; to a method expecting a &lt;code&gt;resourceId&lt;/code&gt;. Or, say, if a method needs &lt;em&gt;both&lt;/em&gt; a &lt;code&gt;customerId&lt;/code&gt; and &lt;code&gt;resourceId&lt;/code&gt;, it’s easy to pass the parameters in the wrong order.&lt;/li&gt;
  &lt;li&gt;Primitives support operations that don’t make sense. For example, if a &lt;code&gt;customerId&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt;, the compiler will happily let you divide it by 2, but that makes no business sense at all. A related problem is when you have &lt;em&gt;units&lt;/em&gt;, such as &lt;code&gt;distanceInFeet&lt;/code&gt; and &lt;code&gt;distanceInMeters&lt;/code&gt;; the lack of units in the type system allow these values to be (incorrectly) added together.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;solving-primitive-obsession-with-value-objects&quot;&gt;Solving Primitive Obsession with Value Objects&lt;/h2&gt;

&lt;p&gt;Value Objects are the general solution to Primitive Obsession. The idea is that you define a (simple) domain object that wraps the primitive type inside a type-safe wrapper type. In some cases, this wrapper type may have some limited domain behavior (such as validation), but in many cases Value Objects are so-called “anemic domain models”, and that’s OK. Value Objects inhabit a middle ground between primitives and full-blown domain objects.&lt;/p&gt;

&lt;p&gt;Value Objects tend to behave similarly to the primitives they replace:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Value Objects are usually immutable.&lt;/li&gt;
  &lt;li&gt;Value Objects usually have value semantics.&lt;/li&gt;
  &lt;li&gt;If a primitive has a useful operation (e.g., string concatenation, integer addition, or even &lt;code&gt;ToString&lt;/code&gt; or &lt;code&gt;GetHashCode&lt;/code&gt; support) that also makes sense for the domain object, then Value Objects usually support those operations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Following these patterns allows Value Objects to essentially be type-safe replacements for primitives. Occasionally some business rules are added (e.g., validation), but just plain old Value Objects work quite well on their own, too.&lt;/p&gt;

&lt;h2 id=&quot;c-and-value-records&quot;&gt;C# and Value Records&lt;/h2&gt;

&lt;p&gt;The modern C# technique for Value Objects is what I call Value Records, and looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;public readonly record struct CustomerId(string Value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, that’s the whole type.&lt;/p&gt;

&lt;p&gt;Breaking it down:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Records provide value semantics, complete with equality, hash code, and &lt;code&gt;ToString&lt;/code&gt; support.&lt;/li&gt;
  &lt;li&gt;Struct records provide a value-type wrapper, avoiding heap allocation (the size of the wrapper &lt;em&gt;is&lt;/em&gt; the size of the wrapped value).&lt;/li&gt;
  &lt;li&gt;Readonly struct records provide immutability.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I prefer to use a single property named &lt;code&gt;Value&lt;/code&gt;, which is similar to &lt;code&gt;Nullable&amp;lt;T&amp;gt;.Value&lt;/code&gt;, except a Value Record &lt;em&gt;always&lt;/em&gt; has a valid &lt;code&gt;Value&lt;/code&gt;. Since the type definition is just a single line, it seems silly to have them follow the one-type-per-file rule; I tend to collect Value Record types and include them in a single source file, usually called &lt;code&gt;Primitives.cs&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;guidelines-for-use&quot;&gt;Guidelines for Use&lt;/h2&gt;

&lt;h3 id=&quot;avoid-sharp-edges&quot;&gt;Avoid Sharp Edges&lt;/h3&gt;

&lt;p&gt;I’ve used Value Records in a few projects now, and I think they work best as internal types. I don’t mean &lt;code&gt;internal&lt;/code&gt;; I mean as types that are created and unwrapped by your own code at the “edges” of your app. Then the core of your app &lt;em&gt;only&lt;/em&gt; deals with the Value Records.&lt;/p&gt;

&lt;p&gt;This way you don’t have to deal with any kind of serialization, which can be a real headache. I recommend you completely ignore Newtonsoft.Json / System.Text.Json / Xml, ASP.NET parameter binding / output formatting, WPF bindings, Entity Framework value conversions, and all other forms of serialization. Instead of trying to automatically support these, just have your own code create the Value Record wrappers when reading the values from an external source (e.g., &lt;code&gt;CustomerId customerId = new(customerIdIntValue)&lt;/code&gt;), and unwrap them when writing values to an external source (e.g., &lt;code&gt;int customerIdIntValue = customerId.Value;&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;choosing-primitives-to-replace&quot;&gt;Choosing Primitives to Replace&lt;/h3&gt;

&lt;p&gt;Not all primitives &lt;em&gt;need&lt;/em&gt; to be Value Records. Choosing which primitives &lt;em&gt;should&lt;/em&gt; be Value Records is a skill, one which everyone is developing right now, and there are no masters of this skill yet AFAIK.&lt;/p&gt;

&lt;p&gt;In my experience, I would say to use primitives by default, but use Value Records in the following situations:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Use Value Records whenever you have similar value types that are used together.
    &lt;ul&gt;
      &lt;li&gt;“Similar” here can mean &lt;em&gt;conceptually&lt;/em&gt; similar or just having a similar &lt;em&gt;name&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Use Value Records whenever you have to &lt;em&gt;guarantee&lt;/em&gt; that a critical value type &lt;em&gt;must&lt;/em&gt; be used only in a particular way.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The classic example of the first situation (similar types) is using Value Records for entity identifiers (&lt;code&gt;CustomerId&lt;/code&gt; and friends). Entity identifiers are conceptually similar &lt;em&gt;and&lt;/em&gt; have similar names, and usually there are multiple methods that deal with different kinds of identifiers at the same time.&lt;/p&gt;

&lt;p&gt;The second situation (critical types) is more of a judgement call. I can at least give an example, though: one of my projects sends emails to users, but also has to deal with users that type in an email address that may or may not be theirs. And there are some severe repercussions for sending emails to people who haven’t asked for them; there’s actual laws in my country about that kind of behavior. So, I created a &lt;code&gt;ValidatedEmail&lt;/code&gt; Value Record for this critical type. In my model, a user has a &lt;code&gt;ValidatedEmail&lt;/code&gt; (whose value may be &lt;code&gt;null&lt;/code&gt;), and the code component that sends emails &lt;em&gt;only&lt;/em&gt; accepts a &lt;code&gt;ValidatedEmail&lt;/code&gt;. It’s comforting to know that the type system itself is enforcing the business rule “only send emails to validated email addresses”.&lt;/p&gt;

&lt;h2 id=&quot;misuse&quot;&gt;Misuse&lt;/h2&gt;

&lt;p&gt;Similar to last week’s technique, the primary misuse of the Value Record technique is &lt;em&gt;overuse&lt;/em&gt;. Once you start feeling the benefits of the stronger type safety from Value Records, you’ll start wanting it everywhere. You may end up temporarily suffering from “Primitive Obsession Obsession”, if you will.&lt;/p&gt;

&lt;p&gt;There’s a maintenance tradeoff with using Value Records: Value Records increase the code complexity. Speficially, Value Records increase the mental burden when reading the code. Put simply: every developer knows what a &lt;code&gt;string&lt;/code&gt; is, but if they see a &lt;code&gt;CustomerId&lt;/code&gt; type, then they need to look that up. Remember, techniques like Value Records are easy to write because they’re in &lt;em&gt;your&lt;/em&gt; head &lt;em&gt;now&lt;/em&gt;, but the resulting code is more difficult to maintain (whether maintained by &lt;em&gt;others&lt;/em&gt; or yourself &lt;em&gt;later&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;After all, it’s not like primitives are evil or anything like that. Primitives are a perfectly fine solution for a lot of data. &lt;code&gt;string CustomerName&lt;/code&gt; is probably just fine; it wouldn’t have any real validation and is unlikely to be confused with something else. Well, that’s true unless your domain has a ton of “names”, in which case maybe it &lt;em&gt;can&lt;/em&gt; be easily confused with another kind of name and &lt;em&gt;should&lt;/em&gt; be a Value Record.&lt;/p&gt;

&lt;h2 id=&quot;history&quot;&gt;History&lt;/h2&gt;

&lt;p&gt;Until records were added to the language, immutable objects were always a bit of a pain, with some going so far as to &lt;a href=&quot;https://github.com/AArnott/ImmutableObjectGraph&quot;&gt;create libraries just to help write immutable types&lt;/a&gt;. The Value Object pattern was used only when absolutely necessary, since it resulted in much more complex code (with a naturally higher probability of containing bugs).&lt;/p&gt;

&lt;p&gt;If you haven’t read it yet, &lt;a href=&quot;https://andrewlock.net/series/using-strongly-typed-entity-ids-to-avoid-primitive-obsession/&quot;&gt;Andrew Lock has a great blog series on using strongly-typed entity IDs to avoid primitive obsession&lt;/a&gt;. I think overall it’s a good series conceptually, but do note that the implementation details are quite dated at this point. Also note how much the complexity is increased by trying to handle only a couple forms of serialization.&lt;/p&gt;

&lt;p&gt;Record types brought immutability to C# as a first-class citizen. The initial record types were class records (reference types), which works great for many immutable types, but tends to be a heavyweight solution for Value Objects. E.g., when wrapping &lt;code&gt;int&lt;/code&gt; values, a &lt;code&gt;class record&lt;/code&gt; wrapper essentially acts as an always-boxed &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These days we have readonly struct records, which are immutable &lt;em&gt;and&lt;/em&gt; lightweight, and a perfect fit for the Value Object pattern.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Carefully replacing some primitive types with Value Records will increase the type safety, correctness, and maintainability of your code.&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Oct 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/10/modern-csharp-techniques-2-value-records.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/10/modern-csharp-techniques-2-value-records.html</guid>
      </item>
    
      <item>
        <title>Modern C# Techniques, Part 1: Curiously Recurring Generic Pattern</title>
        <description>&lt;p&gt;I’m starting a new series today looking at some modern C# techniques. Part of what I like about C# is that the language is always improving, and those improvements bring newer code patterns with them.&lt;/p&gt;

&lt;p&gt;Today’s topic is not actually &lt;em&gt;new&lt;/em&gt;, but many developers haven’t seen it before, so it’s worth taking a look at. As with many of the techniques I’ll be discussing, I’m not sure if this one has a name, so I am just calling it whatever I call it in my head.&lt;/p&gt;

&lt;h2 id=&quot;the-curiously-recurring-generic-pattern&quot;&gt;The Curiously Recurring Generic Pattern&lt;/h2&gt;

&lt;div class=&quot;alert alert-info&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;The “curious” name for this pattern comes from the C++ world, where it was called the Curiously Recurring Template Pattern. So in C# I just call it the Curiously Recurring Generic Pattern, since it’s essentially the same thing but with generics instead of templates. &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot; class=&quot;alert-link&quot;&gt;According to Wikipedia&lt;/a&gt;, it’s actually “F-bound polymorphism”, but I’m not going to remember that.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;The Curiously Recurring Generic Pattern is when an interface (or base type) takes a generic parameter that is its own derived type. A simple example looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;interface IExample&amp;lt;TDerived&amp;gt;
{
}

class MyExample : IExample&amp;lt;MyExample&amp;gt;
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;but-why-tho&quot;&gt;But Why Tho?&lt;/h2&gt;

&lt;p&gt;It essentially comes down to typing. If an interface (or base type) wants to use the &lt;em&gt;full, derived type&lt;/em&gt; as a method parameter or return value, then it can define those methods itself without putting any burdern on the derived type.&lt;/p&gt;

&lt;p&gt;Consider a familiar example from the .NET BCL: &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1?view=net-6.0&amp;amp;WT.mc_id=DT-MVP-5000058&quot;&gt;is defined&lt;/a&gt; as thus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;public interface IEquatable&amp;lt;T&amp;gt;
{
  bool Equals(T? other);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is used as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;sealed class MyEquatable : IEquatable&amp;lt;MyEquatable&amp;gt;
{
  public bool Equals(MyEquatable? other) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The thing to note here is that &lt;code&gt;MyEquatable.Equals&lt;/code&gt; implements &lt;code&gt;IEquatable&amp;lt;T&amp;gt;.Equals&lt;/code&gt; with a &lt;em&gt;strongly-typed&lt;/em&gt; &lt;code&gt;MyEquatable&lt;/code&gt; argument. If the Curiously Recurring Generic Pattern wasn’t used, then &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt; would just be &lt;code&gt;IEquatable&lt;/code&gt; (taking an &lt;code&gt;object&lt;/code&gt; argument), losing type safety and efficiency.&lt;/p&gt;

&lt;h2 id=&quot;adding-a-generic-constraint&quot;&gt;Adding a Generic Constraint&lt;/h2&gt;

&lt;p&gt;The interface (or base type) may also use itself as a generic constraint. It doesn’t &lt;em&gt;have&lt;/em&gt; to (the examples above don’t), but sometimes it’s useful, particularly for base types. The Curiously Recurring Generic Pattern with generic constraints looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;abstract class ExampleBase&amp;lt;TDerived&amp;gt;
    where TDerived : ExampleBase&amp;lt;TDerived&amp;gt;
{
  // Methods in here can use `(TDerived)this` freely.
  // This is particularly useful if this interface wants to *return* a value of TDerived.
  public virtual TDerived Something() =&amp;gt; (TDerived)this;
}

class AnotherExample : ExampleBase&amp;lt;AnotherExample&amp;gt;
{
  // Implicitly has `public AnotherExample Something();` defined.
  // The base class method already has the correct return type.
  // (Can still override if desired).
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As noted in the comments above, this approach is useful if &lt;code&gt;TDerived&lt;/code&gt; is used as a &lt;em&gt;return&lt;/em&gt; type. As one example, this is common with fluent APIs.&lt;/p&gt;

&lt;p&gt;More generally, the generic constraint is needed in either of these situations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The base type needs to treat a &lt;code&gt;ExampleBase&amp;lt;TDerived&amp;gt;&lt;/code&gt; instance (e.g., &lt;code&gt;this&lt;/code&gt;) as its derived type (i.e., &lt;code&gt;(TDerived)this&lt;/code&gt;). This can also come up when passing &lt;code&gt;this&lt;/code&gt; to other methods.&lt;/li&gt;
  &lt;li&gt;The base type needs to treat a &lt;code&gt;TDerived&lt;/code&gt; as a &lt;code&gt;ExampleBase&amp;lt;TDerived&amp;gt;&lt;/code&gt;, e.g., calling private base methods on an instance of type &lt;code&gt;TDerived&lt;/code&gt; &lt;em&gt;other&lt;/em&gt; than &lt;code&gt;this&lt;/code&gt;. In this case no explicit cast is necessary.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;crgp-and-default-interface-methods&quot;&gt;CRGP and Default Interface Methods&lt;/h2&gt;

&lt;p&gt;Similar to regular interface methods, the Curiously Recurring Generic Pattern can enhance the type safety of &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods?WT.mc_id=DT-MVP-5000058&quot;&gt;default interface methods&lt;/a&gt; if necessary. This is similar to using CRGP with base types, except interfaces cannot have state. Put another way, this enables strongly-typed traits, but falls short of mixins.&lt;/p&gt;

&lt;h2 id=&quot;crgp-and-static-interface-methods-and-operators&quot;&gt;CRGP and Static Interface Methods (and Operators)&lt;/h2&gt;

&lt;p&gt;One possibility for CRGP with &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members?WT.mc_id=DT-MVP-5000058&quot;&gt;static interface methods&lt;/a&gt; is to define operators (or other static methods) with the proper type signatures. Previously, CRGP required a base type to define operators (e.g., &lt;a href=&quot;https://github.com/StephenCleary/Comparers/blob/48cd202db5d7ea7209cc4248bf6a531d3752f170/src/Nito.Comparers.Core/EquatableBaseWithOperators.cs&quot;&gt;&lt;code&gt;EquatableBaseWithOperators&amp;lt;TDerived&amp;gt;&lt;/code&gt; in my Nito.Comparers library&lt;/a&gt;), but using CRGP with static interface methods allows strong typing for operator signatures (e.g., &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.numerics.iunarynegationoperators-2?view=net-7.0&amp;amp;WT.mc_id=DT-MVP-5000058&quot;&gt;&lt;code&gt;IUnaryNegationOperators&amp;lt;TSelf, TResult&amp;gt;&lt;/code&gt;&lt;/a&gt; is an interface that defines &lt;code&gt;operator-&lt;/code&gt; with the proper type signature).&lt;/p&gt;

&lt;h2 id=&quot;misuse&quot;&gt;Misuse&lt;/h2&gt;

&lt;p&gt;Like other code patterns, the CRGP can be misused. IMO the most common misuse of this pattern is &lt;em&gt;overuse&lt;/em&gt;. Bear in mind CRGP isn’t powerful enough to provide mixins - even with default interface methods (which provide traits, not mixins).&lt;/p&gt;

&lt;p&gt;Also, CRGP tends to make the code more complex. There’s a tradeoff there, and you need to keep maintainability in mind.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;The Curiously Recurring Generic Pattern isn’t actually new, and it isn’t often necessary, but it’s a nice tool to have when you do need it.&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 4: Polling</title>
        <description>&lt;p&gt;So far in this series, I’ve talked about how to request and detect cancellation, but for the next couple of posts I’ll be switching perspectives and discussing ways to respond to cancellation.&lt;/p&gt;

&lt;p&gt;I know I’ve probably said this a half dozen times already, but it bears repeating: cancellation is cooperative. Your code will be provided a &lt;code&gt;CancellationToken&lt;/code&gt;, and it must &lt;em&gt;do&lt;/em&gt; something with that &lt;code&gt;CancellationToken&lt;/code&gt; in order to be cancelable. Most of the time, this is just passing the &lt;code&gt;CancellationToken&lt;/code&gt; down to lower-level APIs, but if you want cancelable code at the lowest level, there are a couple of other options. The one we’re looking at today is polling.&lt;/p&gt;

&lt;h2 id=&quot;how-to-poll&quot;&gt;How to Poll&lt;/h2&gt;

&lt;p&gt;The normal pattern is to periodically call &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do synchronous work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The example code above checks the cancellation token &lt;em&gt;before&lt;/em&gt; it starts work, which is a good general practice. It is possible that the token is already cancelled by the time your operation starts running.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; will check to see if cancellation is requested, and if it is, it will throw &lt;code&gt;OperationCanceledException&lt;/code&gt;. So it handles the proper reporting of cancellation for you; your code should just let that exception propagate out of the method.&lt;/p&gt;

&lt;p&gt;One question you’ll need to answer is how &lt;em&gt;often&lt;/em&gt; to poll. There really isn’t a good answer for this; ideally you probably want to poll a few times a second, but when you’re talking about CPU-bound code running on potentially very different machines, it’s pretty much a guess at where in the code the &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; should go. Just put it in the best place(s), run some tests to see if cancellation feels responsive enough, and that’s the best you can do.&lt;/p&gt;

&lt;h2 id=&quot;how-not-to-poll&quot;&gt;How Not to Poll&lt;/h2&gt;

&lt;p&gt;There’s a sadly common antipattern regarding polling for cancellation, particularly in infinite loops: the “while not cancelled” loop, which looks like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingForever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FailFast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Bad code! Do not use!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When this code runs, it will periodically check the cancellation token; but when cancellation is requested, the method just returns early. This method doesn’t satisfy the cancellation contract of throwing an exception on cancellation. This means that the calling code cannot know whether the method ran to completion or whether it was cancelled.&lt;/p&gt;

&lt;p&gt;The proper solution is to use &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt;, even for infinite loops:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingForever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;when-to-poll&quot;&gt;When to Poll&lt;/h2&gt;

&lt;p&gt;Polling is an appropriate option for observing cancellation if your code is synchronous, such as CPU-bound code. Cancellation is often thought of as only a concern for asynchronous code; it was explicitly pointed out in the documentation for &lt;code&gt;async&lt;/code&gt; when &lt;code&gt;async&lt;/code&gt; was introduced. But cancellation in .NET predates &lt;code&gt;async&lt;/code&gt;, and cancellation is just as applicable to synchronous code as to asynchronous code. In fact, &lt;code&gt;Parallel&lt;/code&gt; loops and PLINQ each have built-in support for cancellation: &lt;code&gt;ParallelOptions.CancellationToken&lt;/code&gt; for &lt;code&gt;Parallel&lt;/code&gt;, and &lt;code&gt;WithCancellation&lt;/code&gt; for PLINQ.&lt;/p&gt;

&lt;p&gt;That’s not to say you can’t use it for asynchronous code. It’s also appropriate to inject a &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; in asynchronous code, if you are not sure whether other methods will respect their cancellation tokens. Remember, taking a &lt;code&gt;CancellationToken&lt;/code&gt; parameter means that the method &lt;em&gt;may&lt;/em&gt; respect cancellation; it may also ignore the token and just ignore any cancellation requests. So your code may want to inject cancellation checks in-between “steps” of its operation. In this case, &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; isn’t so much “polling” as it is an “occasional check”:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoComplexWorkAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// From testing, it appears that DoStep1Async and DoStep2Async do not always cancel when requested.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoStep1Async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoStep2Async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you &lt;em&gt;can&lt;/em&gt; sprinkle calls to &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; throughout your code like this, I only do this when testing indicates that the code does not respect cancellation. In other words, I assume that &lt;code&gt;DoStep1Async&lt;/code&gt; and &lt;code&gt;DoStep2Async&lt;/code&gt; will respect cancellation until proven otherwise by testing.&lt;/p&gt;

&lt;p&gt;It is also appropriate to use &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; at certain points where your code is about to do something expensive. Just adding a cancellation check there means your code won’t have to do the expensive work if it’s cancelled anyway.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Polling - implemented by periodic calls to &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; - is one way to respond to cancellation requests. This is the common solution for synchronous, CPU-bound methods, and can also be used in a few other scenarios. Most asynchronous code does not use polling; we’ll cover that scenario next time!&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/03/cancellation-4-polling.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/03/cancellation-4-polling.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 3: Detecting Cancellation</title>
        <description>&lt;p&gt;It’s not uncommon to want to detect whether the cancellation actually canceled anything or not. Cancellation is cooperative, and sometimes the code requesting cancellation needs to know whether that cancellation actually took place, or whether the operation just completed normally.&lt;/p&gt;

&lt;p&gt;As a reminder, the cancellation contract has a way to communicate that: methods that take &lt;code&gt;CancellationToken&lt;/code&gt;, by convention, will throw &lt;code&gt;OperationCanceledException&lt;/code&gt; when they are cancelled. This is true for all BCL methods, and should be true for your code as well. Later in this series we’ll cover the best ways for code to respond to cancellation requests, all of which satisfy this contract, i.e., throwing &lt;code&gt;OperationCanceledException&lt;/code&gt; when they cancel.&lt;/p&gt;

&lt;h2 id=&quot;responding-to-cancellation&quot;&gt;Responding to Cancellation&lt;/h2&gt;

&lt;p&gt;The most common scenario for detecting cancellation is to avoid taking the normal error path if the code has been cancelled. Usually, the &lt;code&gt;OperationCanceledException&lt;/code&gt; is just ignored:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TryDoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Normal error handling; log, etc.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above will log any unexpected errors, but will ignore cancellation exceptions.&lt;/p&gt;

&lt;p&gt;If your code must do something &lt;em&gt;different&lt;/em&gt; when a cancellation happens, then you can handle that in a &lt;code&gt;catch&lt;/code&gt; block. Well, first, I’d recommend taking a step back and asking yourself if you &lt;em&gt;really have&lt;/em&gt; to do that, because it’s unusual and raises concerns about the code design, and it can be difficult to test as well. But if you must:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Normal error handling; log, etc.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;taskcanceledexception&quot;&gt;TaskCanceledException&lt;/h2&gt;

&lt;p&gt;You may notice that there is another cancellation exception type: &lt;code&gt;TaskCanceledException&lt;/code&gt;. This is raised by some APIs instead of &lt;code&gt;OperationCanceledException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a general rule, I recommend you completely ignore &lt;code&gt;TaskCanceledException&lt;/code&gt;. Some APIs just raise &lt;code&gt;OperationCanceledException&lt;/code&gt;, even if they deal with cancelled tasks. And since &lt;code&gt;TaskCanceledException&lt;/code&gt; derives from &lt;code&gt;OperationCanceledException&lt;/code&gt;, your cancellation exception handler code can just use &lt;code&gt;OperationCanceledException&lt;/code&gt;, ignore &lt;code&gt;TaskCanceledException&lt;/code&gt; completely, and it will work everywhere.&lt;/p&gt;

&lt;div class=&quot;alert alert-danger&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-exclamation-triangle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;Do not catch &lt;code&gt;TaskCanceledException&lt;/code&gt;. Catch &lt;code&gt;OperationCanceledException&lt;/code&gt; instead.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;operationcanceledexceptioncancellationtoken&quot;&gt;OperationCanceledException.CancellationToken&lt;/h2&gt;

&lt;p&gt;You may also notice that &lt;code&gt;OperationCanceledException&lt;/code&gt; has a &lt;code&gt;CancellationToken&lt;/code&gt; property. This is the token that caused the cancellation. That is, if it’s set; not all APIs set this value on the exceptions they throw.&lt;/p&gt;

&lt;p&gt;If your code needs to determine whether &lt;em&gt;it&lt;/em&gt; cancels the operation or whether something &lt;em&gt;else&lt;/em&gt; cancels the operation, then you might be tempted to use this property. But I recommend that your code ignore this property. When linked cancel tokens are used (a topic I’ll cover in a future post), it’s possible that the token in this property is not actually the root cause of the cancellation.&lt;/p&gt;

&lt;p&gt;More specifically:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FailFast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Bad code; do not use!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling for &amp;quot;our&amp;quot; cancellation only.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above has a problem: depending on the implementation of &lt;code&gt;DoThingAsync&lt;/code&gt;, it’s possible that &lt;code&gt;cts&lt;/code&gt; will be cancelled, and that cancellation will cause &lt;code&gt;DoThingAsync&lt;/code&gt; to throw &lt;code&gt;OperationCanceledException&lt;/code&gt;, and for the token referenced by that exception to be &lt;em&gt;different&lt;/em&gt; than the &lt;code&gt;cts&lt;/code&gt;’s token.&lt;/p&gt;

&lt;p&gt;If you do need to do special processing for when this specific cancellation happens, I recommend something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling for &amp;quot;our&amp;quot; cancellation only.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;Technically,&lt;/em&gt; the semantics of this are not “did my token cause the cancellation”, but rather “did cancellation happen and is my token requesting cancellation”. But in every case I’ve seen in the real world, the alternative semantics have been sufficient.&lt;/p&gt;

&lt;div class=&quot;alert alert-danger&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-exclamation-triangle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;Do not use &lt;code&gt;OperationCanceledException.CancellationToken&lt;/code&gt;. It doesn’t work as expected.&lt;/p&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/03/cancellation-3-detecting-cancellation.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/03/cancellation-3-detecting-cancellation.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 2: Requesting Cancellation</title>
        <description>&lt;p&gt;&lt;a href=&quot;/2022/02/cancellation-1-overview.html&quot;&gt;Last time&lt;/a&gt; we covered the basic cancellation contract. Responding code takes a &lt;code&gt;CancellationToken&lt;/code&gt;, which is a way to communicate a cancellation request. Today we’re looking at how to create &lt;code&gt;CancellationToken&lt;/code&gt;s and how to request cancellation.&lt;/p&gt;

&lt;h2 id=&quot;cancellationtokensource&quot;&gt;CancellationTokenSource&lt;/h2&gt;

&lt;p&gt;Some &lt;code&gt;CancellationToken&lt;/code&gt;s are provided by a framework or library that you’re using. For example, ASP.NET will provide you a &lt;code&gt;CancellationToken&lt;/code&gt; that represents an unexpected client disconnect. As another example, Polly can provide your delegate with a &lt;code&gt;CancellationToken&lt;/code&gt; that represents a more generic cancellation (e.g., a timeout policy being triggered).&lt;/p&gt;

&lt;p&gt;For other scenarios, you’ll need to provide your own &lt;code&gt;CancellationToken&lt;/code&gt;. You can use the &lt;code&gt;CancellationToken&lt;/code&gt; constructor or &lt;code&gt;CancellationToken.None&lt;/code&gt; to create a cancellation token that is either signalled (and always signalled) or unsignalled (and never signalled).&lt;/p&gt;

&lt;p&gt;But in the general case, when you want to create a &lt;code&gt;CancellationToken&lt;/code&gt; that can be cancelled later, then you’ll need to use &lt;code&gt;CancellationTokenSource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;CancellationTokenSource&lt;/code&gt; controls its own set of &lt;code&gt;CancellationToken&lt;/code&gt;s. Each &lt;code&gt;CancellationToken&lt;/code&gt; created from a &lt;code&gt;CancellationTokenSource&lt;/code&gt; is just a small &lt;code&gt;struct&lt;/code&gt; that refers back to its &lt;code&gt;CancellationTokenSource&lt;/code&gt;. A &lt;code&gt;CancellationToken&lt;/code&gt; can only respond to cancellation requests; the &lt;code&gt;CancellationTokenSource&lt;/code&gt; is necessary to request cancellation. So the requesting code creates the &lt;code&gt;CancellationTokenSource&lt;/code&gt; and keeps a reference to it (using that reference later to request cancellation), and the responding code just gets a &lt;code&gt;CancellationToken&lt;/code&gt; and uses that to respond to the cancellation requests.&lt;/p&gt;

&lt;h2 id=&quot;timeouts&quot;&gt;Timeouts&lt;/h2&gt;

&lt;p&gt;One common need for cancellation is implementing a timeout. The solution is to have a timer that requests cancellation when it expires. This is actually common enough that &lt;code&gt;CancellationTokenSource&lt;/code&gt; has this behavior built-in. You can either use the &lt;code&gt;CancellationTokenSource&lt;/code&gt; constructor that takes a delay, or call &lt;code&gt;CancelAfter&lt;/code&gt; on an existing &lt;code&gt;CancellationTokenSource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, if you want to apply a timeout to a code scope:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingWithTimeoutAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Create a CTS that cancels after 5 minutes.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeSpan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FromMinutes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Pass the token for that CTS to lower-level code.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// At the end of this method, the CTS is disposed.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// All of its tokens should not be used after this point.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;manual-cancellation&quot;&gt;Manual Cancellation&lt;/h2&gt;

&lt;p&gt;For more general cancellation needs, create a &lt;code&gt;CancellationTokenSource&lt;/code&gt;, and at some point in the future call its &lt;code&gt;Cancel&lt;/code&gt; method to manually request cancellation.&lt;/p&gt;

&lt;p&gt;One example is a GUI application with an actual “Cancel” button:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationTokenSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Create a CTS for manual cancellation requests.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Pass the token for that CTS to lower-level code.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display error in UI.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CancelButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Manually cancel the CTS.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above shows the basic idea, but has some serious problems that you wouldn’t want to have in production. For one thing, the cancel button can be clicked when &lt;code&gt;_cts&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, causing a &lt;code&gt;NullReferenceException&lt;/code&gt;. Also, the start button handler will blindly overwrite any &lt;code&gt;_cts&lt;/code&gt; value, ignoring any existing ongoing operation.&lt;/p&gt;

&lt;p&gt;The proper resolution of these issues depends on your desired user experience and nature of the operation. Just to make this example more complete and production-ready, let’s implement the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Either the start or cancel buttons should be enabled at any time, never both.&lt;/li&gt;
  &lt;li&gt;If the operation completes on its own, the start button should be enabled and the cancel button disabled.&lt;/li&gt;
  &lt;li&gt;If the operation is cancelled, the start button should remain disabled until the operation completes (either successfully or with an &lt;code&gt;OperationCanceledException&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;After the operation is cancelled, the cancel button remains enabled but becomes a noop.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These requirements result in this kind of code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationTokenSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Create a CTS for manual cancellation requests.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Pass the token for that CTS to lower-level code.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display success in UI.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display error in UI.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CancelButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Manually cancel the CTS.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may wish to have different requirements. For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Either the start or cancel buttons should be enabled at any time, never both.&lt;/li&gt;
  &lt;li&gt;If the operation completes on its own, the start button should be enabled and the cancel button disabled.&lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;If the operation is cancelled, the start button should remain disabled until the operation completes (either successfully or with an `OperationCanceledException`).&lt;/s&gt;
    &lt;p&gt;&lt;em&gt;If one operation is cancelled, the start button should become enabled immediately. Any cancelled operations no longer cause any UI updates.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;After the operation is cancelled, the cancel button remains enabled but becomes a noop.&lt;/s&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since the new requirements allow the user to start a new operation &lt;em&gt;as soon as the old operation is cancelled&lt;/em&gt; (without waiting for the old operation to complete), the “update the UI” code needs to be guarded to ensure only the current operation updates the UI:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationTokenSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Create a CTS for manual cancellation requests.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// In this method, we can check whether we are the current operation by doing (cts == _cts)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This works because _cts changes every time the start button is clicked.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Pass the token for that CTS to lower-level code.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display success in UI.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display error in UI.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CancelButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Manually cancel the CTS.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Ensure cancelled operations do not update the UI with success/errors&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There are many other options available, depending on your desired user experience. For example, you might choose to keep the start button enabled and just have it implicitly cancel the previous operation (if any). Whatever you end up with, just be sure to walk through all the possible states of your UI and ensure that your handlers are interacting with your &lt;code&gt;CancellationTokenSource&lt;/code&gt; instances appropriately.&lt;/p&gt;

&lt;h2 id=&quot;cleaning-up-cancelling-and-disposing&quot;&gt;Cleaning Up: Cancelling and Disposing&lt;/h2&gt;

&lt;p&gt;To avoid resource leaks, it’s important to clean up your &lt;code&gt;CancellationTokenSource&lt;/code&gt; instances. There are a couple of kinds of resources that are cleaned up: first, the timeout timer (if any) is freed; second, any “listeners” attached to &lt;code&gt;CancellationToken&lt;/code&gt;s are freed (we’ll cover “listening” registrations later in this series). This cleanup is done when the &lt;code&gt;CancellationTokenSource&lt;/code&gt; is cancelled &lt;em&gt;or&lt;/em&gt; when it’s disposed. You can either cancel or dispose, but you should ensure one or the other is done to avoid resource leaks.&lt;/p&gt;

&lt;p&gt;The examples in this blog post always dispose the &lt;code&gt;CancelltionTokenSource&lt;/code&gt; when the responding code is done executing (and thus the &lt;code&gt;CancellationToken&lt;/code&gt;s are no longer used). If the &lt;code&gt;CancellationToken&lt;/code&gt; is saved and used later, then you &lt;em&gt;don’t&lt;/em&gt; want to dispose the &lt;code&gt;CancellationTokenSource&lt;/code&gt;. In that case, you’d want to keep the &lt;code&gt;CancellationTokenSource&lt;/code&gt; alive until you are sure that all code is done with its &lt;code&gt;CancellationToken&lt;/code&gt;s. This is a more advanced case, and sometimes it’s more convenient to cancel the &lt;code&gt;CancellationTokenSource&lt;/code&gt; rather than disposing it.&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/03/cancellation-2-requesting-cancellation.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/03/cancellation-2-requesting-cancellation.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 1: Overview</title>
        <description>&lt;p&gt;Cancellation is a topic that I haven’t written on much yet, because the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads?WT.mc_id=DT-MVP-5000058&quot;&gt;Microsoft documentation&lt;/a&gt; is quite good. But after answering many questions for many years, I thought it would be a good topic to cover once, exhaustively.&lt;/p&gt;

&lt;h2 id=&quot;cooperative-cancellation&quot;&gt;Cooperative Cancellation&lt;/h2&gt;

&lt;p&gt;Cancellation in .NET is &lt;em&gt;cooperative&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What this really means is that one part of the code Requests cancellation, and another part of the code Responds to that request. We often talk about some code “cancelling” other code, but what actually happens is that the requesting code just politely notifies the other code that it would like it to please stop, and the responding code may react to that cancellation request in any way it chooses. The responding code may immediately stop what it is doing, or it may continue until it reaches a valid stopping point, or it may ignore the cancellation request completely.&lt;/p&gt;

&lt;p&gt;So, the important takeaway here is that the responding code must respond to the cancellation request in order for cancellation to actually &lt;em&gt;cancel&lt;/em&gt; anything.&lt;/p&gt;

&lt;p&gt;This discussion usually brings up a question: What about code that doesn’t cooperate? I.e., how do I cancel uncancelable code? This is actually an advanced scenario, so I’ll discuss it (with solutions) at the end of this series.&lt;/p&gt;

&lt;h2 id=&quot;cancellation-tokens-and-the-90-case&quot;&gt;Cancellation Tokens and the 90% Case&lt;/h2&gt;

&lt;p&gt;In .NET, a cancellation token is the “carrier” of a cancellation request. The requesting code will cancel a cancellation token, and the responding code reacts to the token being cancelled. We’ll look at the details of how to create and cancel tokens - as well as how to respond to them - in future posts. For now, it’s sufficient to know that the cancellation token is how the cancellation request is passed from the requesting code to the responding code.&lt;/p&gt;

&lt;p&gt;In fact, I’d say about 90% of the cancellation code you’ll need to write is simply that: add a &lt;code&gt;CancellationToken&lt;/code&gt; parameter to your method and then pass it down to whatever APIs you call:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intermediateValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoFirstStepAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSecondStepAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intermediateValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A &lt;code&gt;CancellationToken&lt;/code&gt; can be any kind of cancellation: a user pressing a Cancel button; a client disconnecting from a server; an application shutting down; a timeout. It shouldn’t matter to your code &lt;em&gt;why&lt;/em&gt; it’s being cancelled; just the fact that it &lt;em&gt;is&lt;/em&gt; being cancelled.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;CancellationToken&lt;/code&gt; may only be cancelled one time; once it is cancelled, it is always cancelled.&lt;/p&gt;

&lt;h2 id=&quot;the-cancellation-contract-method-signature&quot;&gt;The Cancellation Contract: Method Signature&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap#cancellation-optional?WT.mc_id=DT-MVP-5000058&quot;&gt;By convention&lt;/a&gt;, the &lt;code&gt;CancellationToken&lt;/code&gt; parameter is usually the last parameter unless an &lt;code&gt;IProgress&amp;lt;T&amp;gt;&lt;/code&gt; parameter is present. It is common to provide an overload or default parameter so that callers do not &lt;em&gt;have&lt;/em&gt; to provide a &lt;code&gt;CancellationToken&lt;/code&gt; if they do not have one; the &lt;code&gt;default&lt;/code&gt; value of a &lt;code&gt;CancellationToken&lt;/code&gt; is the same as &lt;code&gt;CancellationToken.None&lt;/code&gt;, i.e., a cancellation token that will never be canceled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// or:&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Some method signatures take both a &lt;code&gt;CancellationToken&lt;/code&gt; and a timeout value as separate parameters. I don’t recommend this for your own code; this is mainly done in the BCL to enable more efficient p/Invokes of methods that take timeout parameters. Unless you’re also p/Invoking APIs that take timeout parameters, I recommend just taking a single &lt;code&gt;CancellationToken&lt;/code&gt; which can represent &lt;em&gt;any&lt;/em&gt; kind of cancellation.&lt;/p&gt;

&lt;p&gt;By taking a &lt;code&gt;CancellationToken&lt;/code&gt; parameter, a method is implicitly claiming that it may respond to cancellation. Technically, this is “may respond”, not “must respond”. In some cases (like interface implementations), a &lt;code&gt;CancellationToken&lt;/code&gt; argument may be ignored. So the presence of a &lt;code&gt;CancellationToken&lt;/code&gt; parameter does not necessarily mean the code &lt;em&gt;must&lt;/em&gt; support cancellation, but it &lt;em&gt;might&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-cancellation-contract-response&quot;&gt;The Cancellation Contract: Response&lt;/h2&gt;

&lt;p&gt;As noted above, when cancellation is requested, the responding code may cancel whatever it is doing, or it may not. Even if it &lt;em&gt;attempts&lt;/em&gt; to cancel, there is usually a race condition and the method may actually complete before the cancellation request can be honored. The cancellation contract handles this by having canceled code throw &lt;code&gt;OperationCanceledException&lt;/code&gt; when the cancellation is observed and has actually canceled some work. If the cancellation request is ignored or if it arrives too late and the work is finished anyway, then the method returns normally without throwing &lt;code&gt;OperationCanceledException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The standard “90% case” code handles this implicitly; if &lt;code&gt;DoFirstStepAsync&lt;/code&gt; or &lt;code&gt;DoSecondStepAsync&lt;/code&gt; throw &lt;code&gt;OperationCanceledException&lt;/code&gt;, then that exception is also propagated out of &lt;code&gt;DoSomethingAsync&lt;/code&gt;. No change to the “90% case” code is necessary:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intermediateValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoFirstStepAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSecondStepAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intermediateValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;alert alert-danger&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-exclamation-triangle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;There are a lot of code examples out there that just silently return early when cancellation is requested. Please do not do this; it’s a violation of the cancellation contract! When the responding code just returns early, the calling code cannot know whether its cancellation request was honored or ignored.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;exception-to-the-90-case&quot;&gt;Exception to the “90% Case”&lt;/h2&gt;

&lt;p&gt;The “90% case” just takes a &lt;code&gt;CancellationToken&lt;/code&gt; parameter and passes it down. There’s one notable exception to this rule: you shouldn’t pass down &lt;code&gt;CancellationToken&lt;/code&gt;s to &lt;code&gt;Task.Run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The reason is that (IMO) the semantics are confusing. A lot of developers pass a delegate and a &lt;code&gt;CancellationToken&lt;/code&gt; to &lt;code&gt;Task.Run&lt;/code&gt; and expect the delegate to be cancelled when the token is cancelled, but that’s not what happens. The &lt;code&gt;CancellationToken&lt;/code&gt; passed to &lt;code&gt;Task.Run&lt;/code&gt; just cancels the &lt;em&gt;scheduling&lt;/em&gt; of the delegate to the thread pool; once that delegate starts running (which happens pretty much immediately), that cancellation token is ignored.&lt;/p&gt;

&lt;p&gt;To put it in example code, this is what many developers write, incorrectly expecting that &lt;code&gt;// Do something&lt;/code&gt; will be canceled after it starts:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Do something, ignoring cancellationToken&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By never passing the &lt;code&gt;CancellationToken&lt;/code&gt; to &lt;code&gt;Task.Run&lt;/code&gt; (which is ignored anyway unless there’s serious thread pool contention or the token is &lt;em&gt;already&lt;/em&gt; cancelled), we make it clearer that the delegate &lt;em&gt;itself&lt;/em&gt; has to respond to the token:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Do something&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// The IDE is telling me cancellationToken is unused,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//    so this delegate code better use it.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/02/cancellation-1-overview.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/02/cancellation-1-overview.html</guid>
      </item>
    
      <item>
        <title>Asynchronous Messaging, Part 5: Miscellaneous Considerations</title>
        <description>&lt;p&gt;This entry in my asynchronous messaging series is kind of a grab bag of miscellaneous topics. I don’t really have enough to say on these to make them their own posts, but some are too important to drop completely. So, here we go!&lt;/p&gt;

&lt;h2 id=&quot;poison--dead-letter-queues&quot;&gt;Poison / Dead Letter Queues&lt;/h2&gt;

&lt;p&gt;When designing your system, you need to decide how to handle queue messages that insist on failing to process. Usually, you plan for some kind of “dead letter queue” to hold these “poison” messages, and then set up alerting or something on that queue. Many cloud queue/worker systems will automatically do this for you: after a certain number of retries, the problematic message is removed from the regular queue and sent to a poison queue instead.&lt;/p&gt;

&lt;p&gt;Just don’t forget to set up alerting on those poison queues!&lt;/p&gt;

&lt;h2 id=&quot;versioning&quot;&gt;Versioning&lt;/h2&gt;

&lt;p&gt;When I design asynchronous messaging systems, I tend to treat the queued messages as a kind of Data Transfer Object (DTO). These messages act as a bridge between two processes: the HTTP application and the backend processor.&lt;/p&gt;

&lt;p&gt;Just like the rest of the system, the DTOs will change over time, and it’s best to be prepared for that. Unlike an HTTP stack, there’s no versioning possible in the URL or in a header. I tend to prefer versioning in the queue name itself, but you could also embed versions in the DTOs themselves. Generally, “storage DTOs” like these only require a single version number (i.e., they only have a major version, not a minor/patch version); this is because you explicitly &lt;em&gt;don’t&lt;/em&gt; want an older consumer to process newer queue messages.&lt;/p&gt;

&lt;h2 id=&quot;mix-and-match&quot;&gt;Mix and Match&lt;/h2&gt;

&lt;p&gt;I’ve pointed out that the cloud queue solutions work out of the box with the cloud backend processor solutions from the same company, including automatic scaling. But you don’t &lt;em&gt;have&lt;/em&gt; to use the same provider for each part of your asynchronous messaging architecture. It’s entirely possible to, e.g., scale Azure Functions based off a RabbitMQ, or wire up a Google Cloud hosted Docker backend to an Amazon SQS queue. Sometimes there are extra costs when crossing cloud providers, and sometimes you have to write a plugin so that your backend will use your kind of queue for its scaling; but it’s certainly possible to mix and match.&lt;/p&gt;

&lt;h2 id=&quot;all-in-one&quot;&gt;All-In-One&lt;/h2&gt;

&lt;p&gt;And then there is the other side: some solutions are all-in-one, complete solutions for asynchronous messaging. Examples of all-in-one solutions are &lt;a href=&quot;https://www.hangfire.io/&quot;&gt;Hangfire&lt;/a&gt; (.NET) and &lt;a href=&quot;https://github.com/collectiveidea/delayed_job&quot;&gt;Delayed Job&lt;/a&gt; (Ruby). Their all-in-one nature means they are easier to set up, but inevitably also means they are less flexible. There are also some very serious considerations you need to look into before adopting an all-in-one solution; what the developers of that solution created may be very different than what your application needs.&lt;/p&gt;

&lt;p&gt;Specifically, you need to look into:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Does it use a durable queue? If not, I would not even consider it. As a corollary, anything that uses Redis as a queue should not be used in its default configuration, including some very popular solutions such as Sidekiq (Ruby) and Bull (NodeJS). If you do wish to use Redis-based message queues, then you should configure Redis to be durable by telling it to write an Append Only File &lt;em&gt;and&lt;/em&gt; telling it to sync that file on every command. Both Hangfire and Delayed Job use a database as a queue, which is &lt;em&gt;just ok&lt;/em&gt; (assuming you already have a database in your architecture), but not &lt;em&gt;ideal&lt;/em&gt; (now your database server has to deal with all the queue messages as well as its normal data).&lt;/li&gt;
  &lt;li&gt;How are jobs serialized - is the serialization backwards-compatible when your library is updated? As an example of this, until recently (early 2019), Hangfire &lt;em&gt;did not support rolling upgrades&lt;/em&gt; due to the way they serialized jobs. Before that time, Hangfire-based applications had to shut down completely before rolling out a Hangfire upgrade, and if a rollback was necessary, they had to shut down completely before doing the rollback, too. Ouch!&lt;/li&gt;
  &lt;li&gt;How are jobs serialized - how much can the “runner” code change? My experience here is more with Hangfire: .NET is pretty specific when it comes to serializing method delegates, and even something like adding a parameter (with a default argument) can cause a failure. Any change like that now requires &lt;em&gt;two&lt;/em&gt; updates instead of one: the first will add the new overload, and once the old jobs have all completed, a second update can roll out to remove the old overload. I’m not as familiar with Delayed Jobs; Ruby is a more dynamic language, so it may not have this problem.&lt;/li&gt;
  &lt;li&gt;How are errors handled? Most all-in-one solutions will automatically retry, but if the job message insists on failing, then it has to do something else with it. By default, Hangfire will leave those job messages in a “failed” state (and it’s up to you to build some kind of notification on that), whereas Delayed Job will &lt;em&gt;delete&lt;/em&gt; those jobs (!).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In conclusion, caveat emptor. Don’t just slap an all-in-one solution into your architecture; a well-thought-out, proper asynchronous messaging solution is almost always the better choice.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2021/02/asynchronous-messaging-5-miscellaneous-considerations.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2021/02/asynchronous-messaging-5-miscellaneous-considerations.html</guid>
      </item>
    
  </channel>
</rss>
