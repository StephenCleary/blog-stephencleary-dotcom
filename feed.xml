<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stephen Cleary (the blog)</title>
    <description>Stephen Cleary's blog: async/await, programming, language design, and other sundry computer science topics.</description>
    <link>https://blog.stephencleary.com/</link>
    <atom:link rel="self" type="application/rss+xml" href="https://blog.stephencleary.com/feed.xml" />
    <atom:link rel="search" type="application/opensearchdescription+xml" href="https://stephencleary.com/opensearch.xml" title="Cleary Search" />
    
      <item>
        <title>C# Advent: The Joy of Immutable Update Patterns</title>
        <description>&lt;p&gt;This is my first-ever post that is part of &lt;a href=&quot;https://csadvent.christmas/&quot;&gt;C# Advent&lt;/a&gt; organized by &lt;a href=&quot;https://x.com/mgroves&quot;&gt;@mgroves&lt;/a&gt;. This year there’s a &lt;a href=&quot;https://www.youtube.com/watch?v=D4udjhRjW4o&quot;&gt;video&lt;/a&gt;, too, including yours-truly singing while wearing my favorite Christmas shirt!&lt;/p&gt;

&lt;h2 id=&quot;joy-to-the-world&quot;&gt;Joy to the World!&lt;/h2&gt;

&lt;blockquote class=&quot;blockquote&quot;&gt;
  &lt;p&gt;Glory to God in the highest, and on earth peace, good will toward men.&lt;/p&gt;

  &lt;footer class=&quot;blockquote-footer text-right&quot;&gt;&lt;cite&gt;Luke 2:14&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;I love Christmas! It’s easily my favorite holiday.&lt;/p&gt;

&lt;p&gt;In spite of difficulties and upheaval in the world (it is 2023 right now), Christmas still stands as a time of refection and remembrance and expectation.&lt;/p&gt;

&lt;p&gt;I do approach Christmas from a Christian perspective, and I enjoy meditating on Jesus’ birth during this time. In particular this year, I’ve been focusing on &lt;em&gt;peace&lt;/em&gt; and &lt;em&gt;joy&lt;/em&gt;, two words commonly associated with Christmas and the coming of the Christ.&lt;/p&gt;

&lt;p&gt;So, when I was considering the topic for my C# Advent article, I particularly wanted one that invoked Peace or Joy. And, when working with C#, there is one aspect of the language that truly does cause feelings of joy whenever I use it. It’s not a single language feature, but rather a collection of language features that all work together in a beatiful way.&lt;/p&gt;

&lt;p&gt;Hence the title of this blog post: The Joy of Immutable Update Patterns. Wow, that sounds nerdy…&lt;/p&gt;

&lt;h2 id=&quot;immutability&quot;&gt;Immutability&lt;/h2&gt;

&lt;p&gt;An immutable type is one whose value can’t change. Immutable types have several advantages, not the least of which is that they’re just easier to reason about. Some languages push immutability very strongly; C# takes a relatively pragmatic approach.&lt;/p&gt;

&lt;p&gt;Immutability varies across the C# ecosystem (and it’s currently seeing a gradual rise in popularity). Most value types are usually immutable (e.g., &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, and &lt;code&gt;Guid&lt;/code&gt;); most reference types are not immutable (e.g., &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;). However, there are lots of exceptions to that general rule; mutable value types are common in performance-sensitive scenarios, and some reference types such as &lt;code&gt;string&lt;/code&gt; are immutable.&lt;/p&gt;

&lt;p&gt;Modern code has a few additional options for immutable types: you can use &lt;code&gt;record class&lt;/code&gt; (C# 9) for immutable reference types and &lt;code&gt;readonly record struct&lt;/code&gt; (C# 10) for immutable value types. There’s also the collections in &lt;code&gt;System.Collections.Immutable&lt;/code&gt; for more complex data structures such as stacks, queues, and dictionaries. Of course, with your own immutable types and collections, their members/elements must be immutable in order for the composite value to be immutable.&lt;/p&gt;

&lt;h2 id=&quot;updating-immutable-data&quot;&gt;Updating Immutable Data&lt;/h2&gt;

&lt;p&gt;Immutable data makes local functions easier to reason about - you &lt;em&gt;know&lt;/em&gt; the data can’t change - but of course every program has to model modifications in some way. One approach is to have a &lt;em&gt;variable&lt;/em&gt; that is mutable, referring to some &lt;em&gt;data&lt;/em&gt; that is immutable. To change the immutable data, you can write code that transitions one immutable value to another.&lt;/p&gt;

&lt;p&gt;It is in this area that C# has been slowly adding enhancements over many years, and is now approaching beautiful code. Code that makes me smile when I write it!&lt;/p&gt;

&lt;h3 id=&quot;switch-expressions&quot;&gt;&lt;code&gt;switch&lt;/code&gt; Expressions&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; expressions (C# 8) are at the core of immutable update patterns. At their simplest, they provide a mapping from one constant to another:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Category&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AdventThing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;AdventThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;AdventThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sheep&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;AdventThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Camel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;AdventThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bethlehem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Place&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArgumentOutOfRangeException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nameof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; expressions are built on &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns?WT.mc_id=DT-MVP-5000058&quot;&gt;pattern matching&lt;/a&gt;, which started in &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/patterns?WT.mc_id=DT-MVP-5000058&quot;&gt;C# 8&lt;/a&gt; (alongside the &lt;code&gt;switch&lt;/code&gt; expression) and have received enhancements in &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/patterns3?WT.mc_id=DT-MVP-5000058&quot;&gt;C# 9&lt;/a&gt;, &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/extended-property-patterns?WT.mc_id=DT-MVP-5000058&quot;&gt;C# 10&lt;/a&gt;, and &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-11.0/list-patterns?WT.mc_id=DT-MVP-5000058&quot;&gt;C# 11&lt;/a&gt;. They’re practically a separate mini-language at this point!&lt;/p&gt;

&lt;p&gt;Switch expressions on their own are powerful, but they’re especially useful alongside &lt;code&gt;with&lt;/code&gt; expressions.&lt;/p&gt;

&lt;h3 id=&quot;with-expressions&quot;&gt;&lt;code&gt;with&lt;/code&gt; Expressions&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;with&lt;/code&gt; expressions are a shorthand way of copying a composite value (i.e., a &lt;code&gt;record class&lt;/code&gt; or &lt;code&gt;readonly record struct&lt;/code&gt;) and changing only the specified properties. A simple example should suffice:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;record&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RoomsAvailable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;RoomsAvailable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myInn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Bethlehem Getaway&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fullInn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myInn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the example above, &lt;code&gt;Full&lt;/code&gt; does not modify the (immutable) inn; it returns a &lt;em&gt;new&lt;/em&gt; inn that is full.&lt;/p&gt;

&lt;p&gt;Combining &lt;code&gt;switch&lt;/code&gt; expressions with &lt;code&gt;with&lt;/code&gt; expressions is where you start to see the beauty of this kind of immutable update pattern:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReserveRoom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RoomsAvailable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RoomsAvailable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RoomsAvailable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;No rooms available.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here’s a method that decrements the available rooms in an &lt;code&gt;Inn&lt;/code&gt;. It is a &lt;em&gt;pure&lt;/em&gt; method; it depends only on its inputs and produces only its outputs, with no mutation. This is the point at which we’re starting to do immutable state transitions.&lt;/p&gt;

&lt;h3 id=&quot;collections&quot;&gt;Collections&lt;/h3&gt;

&lt;p&gt;I tend to use &lt;code&gt;System.Collections.Immutable&lt;/code&gt; whenever I need something stack- or queue- or dictionary-like in an immutable context. These types all have methods like &lt;code&gt;Add&lt;/code&gt; that &lt;em&gt;return&lt;/em&gt; a new collection rather than modifying one in place. Internally, the immutable collections share internal data structures, so this isn’t as inefficient as copying the entire collection; immutable collections can never be as memory-efficient as mutable collections, but they’re usually efficient enough to not be an issue. I find immutable collections satisfy my needs quite well.&lt;/p&gt;

&lt;p&gt;However, I would be remiss if I didn’t mention that C# has added a new way to create collections (including &lt;code&gt;ImmutableArray&amp;lt;T&amp;gt;&lt;/code&gt;). It’s very reminiscient of JavaScript’s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread operator&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;ImmutableArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ImmutableArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ImmutableArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;..]];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// result: [3, 5, 7, 11, 13]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Equivalent to:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//   ImmutableArray&amp;lt;int&amp;gt; result = list.SetItem(index, 7);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As of this writing, though, the implementation iterates over all the elements and builds an entirely new collection. This is quite inefficient for immutable collections, so I do not use C# 12’s &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions?WT.mc_id=DT-MVP-5000058&quot;&gt;collection expressions&lt;/a&gt; when working with immutable data. (But for mutable code, they rock!)&lt;/p&gt;

&lt;h2 id=&quot;application-unidirectional-data-flow&quot;&gt;Application: Unidirectional Data Flow&lt;/h2&gt;

&lt;p&gt;Let’s build this up into something a bit more complex! We can give each inn an actual collection of rooms, and just acquire an available one when requested.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;record&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;record&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ImmutableHashSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReserveRoom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;room&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FirstOrDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;??&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;No rooms available.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Rooms&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;room&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Available&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myInn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Bethlehem Getaway&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Enumerable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ToImmutableHashSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resultInn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReserveRoom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myInn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we have some more complex state, and our &lt;code&gt;ReserveRoom&lt;/code&gt; method now finds a room, reserves it, and returns the new composite state of the inn. I often find it useful to have these modifier methods also return some indication of what they did - in this case, it can return the room that was reserved. Tuples are convenient for multiple return values:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RoomId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReserveRoom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;room&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FirstOrDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;??&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;No rooms available.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Rooms&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rooms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;room&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Available&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you squint a bit, you can see &lt;code&gt;ReserveRoom&lt;/code&gt; as being like a Redux reducer (for a single action: reserving a room). Many years ago, React and Redux took the world by storm. Although Redux has fallen out of favor in some circles, it made some ideas popular, and those continue to live on.&lt;/p&gt;

&lt;p&gt;Specifically, the idea of Unidirectional Data Flow is one that has taken hold, particularly in UI applications. The core idea is that the application has a single instance of composite immutable state, and that this state is only changed by applying pure functions to it (commonly called “reducers”). Other parts of the application (including the UI) listen for and respond to state changes. UDF is an architecture that is overkill for extremely simple applications, but is an absolute lifesaver when there is significant complexity.&lt;/p&gt;

&lt;p&gt;Unidirectional Data Flow (UDF) can go by several names. Model-View-Intent (MVI) is an architecture common on mobile platforms that is based on UDF. Another fairly common architecture name is The Elm Architecture (TEA, or sometimes just Elm). Today most C# UI applications still use a basic MVVM style of architecture, but I expect with the language changes that better support immutable update patterns, we’ll start to see more adoption of UDF architectures in C#. At least, I hope so!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this post has been interesting to you! Personally, I do enjoy writing code combining &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;with&lt;/code&gt; expressions. I think the resulting code is really elegant, and I hope you got some joy out of this! Merry Christmas!&lt;/p&gt;

&lt;!--
## Application: Building Asynchronous Primitives

And now I'm going to completely switch gears. Because immutable state updates are great for application state, but they're also great for doing threadsafe code.

One advantage of immutable data is that - since it is immutable - it can be safely shared among any threads! There's usually just one variable that _refers_ to the immutable state, and that variable is the only thing that needs actual multithreaded protection. So, let's use this aspect to improve on a well-known primitive.

I have an &quot;Async Masterclass&quot; talk that I've given a few times, and in that talk one of the topics I cover is building your own asynchronous synchronization primitives. A simple example is an `AsyncManualResetEvent`, which in my (current) slides ends up looking like this:


&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AsyncManualResetEvent&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TaskCompletionSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AsyncManualResetEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;_mutex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;_tcs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TaskCreationOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RunContinuationsAsynchronously&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WaitUntilSetAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;_tcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TrySetResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsCompleted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;_tcs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TaskCreationOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RunContinuationsAsynchronously&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;


And, sure, there's nothing really _wrong_ with this, but there's some parts that aren't clear to many developers. How can I use `lock` in this asynchronous primitive? And `RunContinuationsAsynchronously` is necessary to avoid a particularly tricky deadlock situation. It's just not code that is 

--&gt;
</description>
        <pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2023/12/the-joy-of-immutable-update-patterns.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2023/12/the-joy-of-immutable-update-patterns.html</guid>
      </item>
    
      <item>
        <title>ConfigureAwait in .NET 8</title>
        <description>&lt;p&gt;I don’t often write “what’s new in .NET” posts, but .NET 8.0 has an interesting addition that I haven’t seen a lot of people talk about. &lt;code&gt;ConfigureAwait&lt;/code&gt; is getting a pretty good overhaul/enhancement; let’s take a look!&lt;/p&gt;

&lt;h2 id=&quot;configureawaittrue-and-configureawaitfalse&quot;&gt;ConfigureAwait(true) and ConfigureAwait(false)&lt;/h2&gt;

&lt;p&gt;First, let’s review the semantics and history of the original &lt;code&gt;ConfigureAwait&lt;/code&gt;, which takes a boolean argument named &lt;code&gt;continueOnCapturedContext&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;await&lt;/code&gt; acts on a task (&lt;code&gt;Task&lt;/code&gt;, &lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ValueTask&lt;/code&gt;, or &lt;code&gt;ValueTask&amp;lt;T&amp;gt;&lt;/code&gt;), its &lt;a href=&quot;/2012/02/async-and-await.html&quot;&gt;default behavior&lt;/a&gt; is to capture a “context”; later, when the task completes, the &lt;code&gt;async&lt;/code&gt; method resumes executing in that context. The “context” is &lt;code&gt;SynchronizationContext.Current&lt;/code&gt; or &lt;code&gt;TaskScheduler.Current&lt;/code&gt; (falling back on the thread pool context if none is provided). This default behavior of continuing on the captured context can be made explicit by using &lt;code&gt;ConfigureAwait(continueOnCapturedContext: true)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ConfigureAwait(continueOnCapturedContext: false)&lt;/code&gt; is useful if you &lt;em&gt;don’t&lt;/em&gt; want to resume on that context. When using &lt;code&gt;ConfigureAwait(false)&lt;/code&gt;, the &lt;code&gt;async&lt;/code&gt; method resumes on any available thread pool thread.&lt;/p&gt;

&lt;p&gt;The history of &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; is interesting (at least to me). Originally, the community recommended using &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; everywhere you could, unless you &lt;em&gt;needed&lt;/em&gt; the context. This is the position I &lt;a href=&quot;https://learn.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming?WT.mc_id=DT-MVP-5000058#configure-context&quot;&gt;recommended in my Async Best Practices article&lt;/a&gt;. There were several discussions during that time frame over why the default was &lt;code&gt;true&lt;/code&gt;, especially from frustrated library developers who had to use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; a lot.&lt;/p&gt;

&lt;p&gt;Over the years, though, the recommendation of “use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; whenever you can” has been modified. The first (albeit minor) shift was instead of “use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; whenever you can”, a simpler guideline arose: use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; in library code and &lt;em&gt;don’t&lt;/em&gt; use it in application code. This is an easier guideline to understand and follow. Still, the complaints about having to use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; continued, with periodic requests to change the default on a project-wide level. These requests have always been rejected by the C# team for language consistency reasons.&lt;/p&gt;

&lt;p&gt;More recently (specifically, since ASP.NET dropped their &lt;code&gt;SynchronizationContext&lt;/code&gt; with ASP.NET Core and fixed all the places where sync-over-async was necessary), there has been a move away from &lt;code&gt;ConfigureAwait(false)&lt;/code&gt;. As a library author, I fully understand how annoying it is to have &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; litter your codebase! Some library authors have just decided not to bother with &lt;code&gt;ConfigureAwait(false)&lt;/code&gt;. For myself, I still use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; in my libraries, but I understand the frustration.&lt;/p&gt;

&lt;div class=&quot;alert alert-info&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;An earlier version of this post incorrectly claimed that the Entity Framework Core team had decided not to use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt;. This was only true in early versions of Entity Framework Core. Entity Framework Core &lt;a href=&quot;https://github.com/dotnet/efcore/pull/21110&quot; class=&quot;alert-link&quot;&gt;added &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; in version 5.0.0&lt;/a&gt; and continues to use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; as of this writing (2023-11-11).&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Since we’re on the topic of &lt;code&gt;ConfigureAwait(false)&lt;/code&gt;, I’d like to note a few common misconceptions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;ConfigureAwait(false)&lt;/code&gt; is not a good way to avoid deadlocks. That’s not its purpose, and it’s a questionable solution at best. In order to avoid deadlocks when doing direct blocking, you’d have to make sure &lt;em&gt;all&lt;/em&gt; the asynchronous code uses &lt;code&gt;ConfigureAwait(false)&lt;/code&gt;, including code in libraries and the runtime. It’s just not a very maintainable solution. There are &lt;a href=&quot;https://learn.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development?WT.mc_id=DT-MVP-5000058&quot;&gt;better solutions available&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ConfigureAwait&lt;/code&gt; configures the &lt;code&gt;await&lt;/code&gt;, not the task. E.g., the &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; in &lt;code&gt;SomethingAsync().ConfigureAwait(false).GetAwaiter().GetResult()&lt;/code&gt; does exactly nothing. Similarly, the &lt;code&gt;await&lt;/code&gt; in &lt;code&gt;var task = SomethingAsync(); task.ConfigureAwait(false); await task;&lt;/code&gt; still continues on the captured context, completely ignoring the &lt;code&gt;ConfigureAwait(false)&lt;/code&gt;. I’ve seen both of these mistakes over the years.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ConfigureAwait(false)&lt;/code&gt; does not mean “run the rest of this method on a thread pool thread” or “run the rest of this method on a different thread”. It only takes effect if the &lt;code&gt;await&lt;/code&gt; yields control and then later resumes the &lt;code&gt;async&lt;/code&gt; method. Specifically, &lt;code&gt;await&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; yield control if its task is already complete; in that case, the &lt;code&gt;ConfigureAwait&lt;/code&gt; has no effect because the &lt;code&gt;await&lt;/code&gt; continues synchronously.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OK, now that we’ve refreshed our understanding of &lt;code&gt;ConfigureAwait(false)&lt;/code&gt;, let’s take a look at how &lt;code&gt;ConfigureAwait&lt;/code&gt; is getting some enhancements in .NET 8. None of the existing behavior is changed; &lt;code&gt;await&lt;/code&gt; without any &lt;code&gt;ConfigureAwait&lt;/code&gt; at all still has the default behavior of &lt;code&gt;ConfigureAwait(true)&lt;/code&gt;, and &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; still has the same behavior, too. But there’s a &lt;em&gt;new&lt;/em&gt; &lt;code&gt;ConfigureAwait&lt;/code&gt; coming into town!&lt;/p&gt;

&lt;h2 id=&quot;configureawaitconfigureawaitoptions&quot;&gt;ConfigureAwait(ConfigureAwaitOptions)&lt;/h2&gt;

&lt;p&gt;There are several new options available for &lt;code&gt;ConfigureAwait&lt;/code&gt;. &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.configureawaitoptions?view=net-8.0&quot;&gt;&lt;code&gt;ConfigureAwaitOptions&lt;/code&gt;&lt;/a&gt; is a new type that provides all the different ways to configure awaitables:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Threading.Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;[Flags]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ContinueOnCapturedContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SuppressThrowing&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ForceYielding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;First, a quick note: this is a &lt;code&gt;Flags&lt;/code&gt; enum; any combination of these options can be used together.&lt;/p&gt;

&lt;p&gt;The next thing I want to point out is that &lt;code&gt;ConfigureAwait(ConfigureAwaitOptions)&lt;/code&gt; is only available on &lt;code&gt;Task&lt;/code&gt; and &lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;, at least for .NET 8. It wasn’t added to &lt;code&gt;ValueTask&lt;/code&gt; / &lt;code&gt;ValueTask&amp;lt;T&amp;gt;&lt;/code&gt; yet. It’s possible that a future release of .NET may add &lt;code&gt;ConfigureAwait(ConfigureAwaitOptions)&lt;/code&gt; for value tasks, but as of now it’s only available on reference tasks, so you’ll need to call &lt;code&gt;AsTask&lt;/code&gt; if you want to use these new options on value tasks.&lt;/p&gt;

&lt;p&gt;Now, let’s consider each of these options in turn.&lt;/p&gt;

&lt;h3 id=&quot;configureawaitoptionsnone-and-configureawaitoptionscontinueoncapturedcontext&quot;&gt;ConfigureAwaitOptions.None and ConfigureAwaitOptions.ContinueOnCapturedContext&lt;/h3&gt;

&lt;p&gt;These two are going to be pretty familiar, except with one twist.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ConfigureAwaitOptions.ContinueOnCapturedContext&lt;/code&gt; - as you might guess from the name - is the same as &lt;code&gt;ConfigureAwait(continueOnCapturedContext: true)&lt;/code&gt;. In other words, the &lt;code&gt;await&lt;/code&gt; will capture the context and resume executing the &lt;code&gt;async&lt;/code&gt; method on that context.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// These all do the same thing&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;continueOnCapturedContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ContinueOnCapturedContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;ConfigureAwaitOptions.None&lt;/code&gt; is the same as &lt;code&gt;ConfigureAwait(continueOnCapturedContext: false)&lt;/code&gt;. In other words, &lt;code&gt;await&lt;/code&gt; will behave perfectly normally, except that it will &lt;em&gt;not&lt;/em&gt; capture the context; assuming the &lt;code&gt;await&lt;/code&gt; does yield (i.e, the task is not already complete), then the &lt;code&gt;async&lt;/code&gt; method will resume executing on any available thread pool thread.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// These do the same thing&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;continueOnCapturedContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here’s the twist: with the new options, the default is to &lt;em&gt;not&lt;/em&gt; capture the context! Unless you explicitly include &lt;code&gt;ContinueOnCapturedContext&lt;/code&gt; in your flags, the context will &lt;em&gt;not&lt;/em&gt; be captured. Of course, the default behavior of &lt;code&gt;await&lt;/code&gt; itself is unchanged: without any &lt;code&gt;ConfigureAwait&lt;/code&gt; at all, &lt;code&gt;await&lt;/code&gt; will behave as though &lt;code&gt;ConfigureAwait(true)&lt;/code&gt; or &lt;code&gt;ConfigureAwait(ConfigureAwaitOptions.ContinueOnCapturedContext)&lt;/code&gt; was used.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Default behavior (no ConfigureAwait): continue on the captured context.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Default flag option (None): do not continue on the captured context.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, that’s something to keep in mind as you start using this new &lt;code&gt;ConfigureAwaitOptions&lt;/code&gt; enum.&lt;/p&gt;

&lt;h3 id=&quot;configureawaitoptionssuppressthrowing&quot;&gt;ConfigureAwaitOptions.SuppressThrowing&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;SuppressThrowing&lt;/code&gt; flag suppresses exceptions that would otherwise occur when &lt;code&gt;await&lt;/code&gt;ing a task. Under normal conditions, &lt;code&gt;await&lt;/code&gt; will observe task exceptions by re-raising them at the point of the &lt;code&gt;await&lt;/code&gt;. Normally, this is exactly the behavior you want, but there are some situations where you just want to wait for the task to complete and you don’t care whether it completes successfully or with an exception. &lt;code&gt;SuppressThrowing&lt;/code&gt; allows you to wait for the completion of a task without observing its result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// These do the same thing&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SuppressThrowing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I expect this will be most useful alongside cancellation. There are some cases where some code needs to cancel a task and then wait for the existing task to complete before starting a replacement task. &lt;code&gt;SuppressThrowing&lt;/code&gt; would be useful in that scenario: the code can &lt;code&gt;await&lt;/code&gt; with &lt;code&gt;SuppressThrowing&lt;/code&gt;, and the method will continue when the task completes, whether it was successful, canceled, or finished with an exception.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Cancel the old task and wait for it to complete, ignoring exceptions.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SuppressThrowing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Start the new task.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationTokenSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you &lt;code&gt;await&lt;/code&gt; with the &lt;code&gt;SuppressThrowing&lt;/code&gt; flag, then the exception &lt;em&gt;is&lt;/em&gt; considered “observed”, so &lt;code&gt;TaskScheduler.UnobservedTaskException&lt;/code&gt; is not raised. The assumption is that you are awaiting the task and deliberately discarding the exception, so it’s not considered unobserved.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;TaskScheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnobservedTaskException&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;never printed&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FromException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SuppressThrowing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;GC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitForPendingFinalizers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s another consideration for this flag as well. When used with a plain &lt;code&gt;Task&lt;/code&gt;, the semantics are clear: if the task faults, the exception is just ignored. However, the same semantics don’t quite work for &lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;, because in that case the &lt;code&gt;await&lt;/code&gt; expression needs to return a value (of type &lt;code&gt;T&lt;/code&gt;). It’s not clear what value of &lt;code&gt;T&lt;/code&gt; would be appropriate to return in the case of an ignored exception, so the current behavior is to throw an &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; at runtime. To help catch this at compile time, a new warning &lt;a href=&quot;https://github.com/dotnet/roslyn-analyzers/pull/6669&quot;&gt;was added&lt;/a&gt;: &lt;code&gt;CA2261&lt;/code&gt; &lt;code&gt;The ConfigureAwaitOptions.SuppressThrowing is only supported with the non-generic Task&lt;/code&gt;. This rule defaults to a warning, but I’d suggest making it an error, since it will always fail at runtime.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FromResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Causes CA2261 warning at build time and ArgumentOutOfRangeException at runtime.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SuppressThrowing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a final note, this is one flag that also affects synchronous blocking in addition to &lt;code&gt;await&lt;/code&gt;. Specifically, you can call &lt;code&gt;.GetAwaiter().GetResult()&lt;/code&gt; to block on the awaiter returned from &lt;code&gt;ConfigureAwait&lt;/code&gt;. The &lt;code&gt;SuppressThrowing&lt;/code&gt; flag will cause exceptions to be ignored whether using &lt;code&gt;await&lt;/code&gt; or &lt;code&gt;GetAwaiter().GetResult()&lt;/code&gt;. Previously, when &lt;code&gt;ConfigureAwait&lt;/code&gt; only took a boolean parameter, you could say “ConfigureAwait configures the await”; but now you have to be more specific: “ConfigureAwait returns a configured awaitable”. And it is now possible that the configured awaitable modifies the behavior of blocking code in addition to the behavior of the &lt;code&gt;await&lt;/code&gt;. &lt;code&gt;ConfigureAwait&lt;/code&gt; is perhaps a slight misnomer now, but it is still &lt;em&gt;primarily&lt;/em&gt; intended for configuring &lt;code&gt;await&lt;/code&gt;. Of course, blocking on asynchronous code still isn’t recommended.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Synchronously blocks on the task (not recommended). Does not throw an exception.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SuppressThrowing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetAwaiter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;configureawaitoptionsforceyielding&quot;&gt;ConfigureAwaitOptions.ForceYielding&lt;/h3&gt;

&lt;p&gt;The final flag is the &lt;code&gt;ForceYielding&lt;/code&gt; flag. I expect this flag will be rarely used, but when you need it, you need it!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ForceYielding&lt;/code&gt; is similar to &lt;code&gt;Task.Yield&lt;/code&gt;. &lt;code&gt;Yield&lt;/code&gt; returns a special awaitable that always claims to be not completed, but schedules its continuations immediately. What this means is that the &lt;code&gt;await&lt;/code&gt; always acts asynchronously, yielding to its caller, and then the &lt;code&gt;async&lt;/code&gt; method continues executing as soon as possible. The &lt;a href=&quot;/2012/02/async-and-await.html&quot;&gt;normal behavior for &lt;code&gt;await&lt;/code&gt;&lt;/a&gt; is to check if its awaitable is complete, and if it is, then continue executing synchronously; &lt;code&gt;ForceYielding&lt;/code&gt; prevents that synchronous behavior, forcing the &lt;code&gt;await&lt;/code&gt; to behave asynchronously.&lt;/p&gt;

&lt;p&gt;For myself, I find forcing asynchronous behavior most useful in unit testing. It can also be used to avoid stack dives in some cases. It may also be useful when implementing asynchronous coordination primitives, such as the ones in my AsyncEx library. Essentially, anywhere where you want to force &lt;code&gt;await&lt;/code&gt; to behave asynchronously, you can use &lt;code&gt;ForceYielding&lt;/code&gt; to accomplish that.&lt;/p&gt;

&lt;p&gt;One point that I find interesting is that &lt;code&gt;await&lt;/code&gt; with &lt;code&gt;ForceYielding&lt;/code&gt; makes the &lt;code&gt;await&lt;/code&gt; behave like it does in JavaScript. In JavaScript, &lt;code&gt;await&lt;/code&gt; &lt;em&gt;always&lt;/em&gt; yields, even if you pass it a resolved promise. In C#, you can now &lt;code&gt;await&lt;/code&gt; a completed task with &lt;code&gt;ForceYielding&lt;/code&gt;, and &lt;code&gt;await&lt;/code&gt; will behave as though it’s not completed, just like JavaScript’s &lt;code&gt;await&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CurrentManagedThreadId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// main thread&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CompletedTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CurrentManagedThreadId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// main thread&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CompletedTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForceYielding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CurrentManagedThreadId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// thread pool thread&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that &lt;code&gt;ForceYielding&lt;/code&gt; by itself also implies &lt;em&gt;not&lt;/em&gt; continuing on the captured context, so it is the same as saying “schedule the rest of this method to the thread pool” or “switch to a thread pool thread”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// ForceYielding forces await to behave asynchronously.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Lack of ContinueOnCapturedContext means the method continues on a thread pool thread.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Therefore, code after this statement will *always* run on a thread pool thread.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForceYielding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;Task.Yield&lt;/code&gt; &lt;em&gt;will&lt;/em&gt; resume on the captured context, so it’s not &lt;em&gt;exactly&lt;/em&gt; like &lt;code&gt;ForceYielding&lt;/code&gt; by itself. It’s actually like &lt;code&gt;ForceYielding&lt;/code&gt; with &lt;code&gt;ContinueOnCapturedContext&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// These do the same thing&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CompletedTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForceYielding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigureAwaitOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ContinueOnCapturedContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, the real value of &lt;code&gt;ForceYielding&lt;/code&gt; is that it can be applied to any task at all. Previously, in the situations where yielding was required, you had to either add a &lt;em&gt;separate&lt;/em&gt; &lt;code&gt;await Task.Yield();&lt;/code&gt; statement or create a custom awaitable. That’s no longer necessary now that &lt;code&gt;ForceYielding&lt;/code&gt; can be applied to any task.&lt;/p&gt;

&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;

&lt;p&gt;It’s great to see the .NET team still making improvements in &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;, all these years later!&lt;/p&gt;

&lt;p&gt;If you’re interested in more of the history and design discussion behind &lt;code&gt;ConfigureAwaitOptions&lt;/code&gt;, check out the &lt;a href=&quot;https://github.com/dotnet/runtime/pull/87067&quot;&gt;pull request&lt;/a&gt;. At one point there &lt;a href=&quot;https://github.com/dotnet/runtime/issues/22144#issuecomment-1561983918&quot;&gt;was&lt;/a&gt; a &lt;code&gt;ForceAsynchronousContinuation&lt;/code&gt; that was dropped before release. It had a more obscure use case, essentially overriding &lt;code&gt;await&lt;/code&gt;’s &lt;a href=&quot;/2012/12/dont-block-in-asynchronous-code.html&quot;&gt;default behavior of scheduling the &lt;code&gt;async&lt;/code&gt; method continuation with &lt;code&gt;ExecuteSynchronously&lt;/code&gt;&lt;/a&gt;. Perhaps a future update will add that back in, or perhaps a future update will add &lt;code&gt;ConfigureAwaitOptions&lt;/code&gt; support to value tasks. We’ll just have to see what the future holds!&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2023/11/configureawait-in-net-8.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2023/11/configureawait-in-net-8.html</guid>
      </item>
    
      <item>
        <title>Padding for Overlaid Structs</title>
        <description>&lt;p&gt;&lt;a href=&quot;/2023/09/memory-mapped-files-overlaid-structs.html&quot;&gt;Last time&lt;/a&gt; we covered the basics of memory-mapped files and how to overlay structs onto the in-memory view of the file. This time we’ll take a look at different techniques to add “padding” or “holes” in our overlaid structs. Sometimes your overlaid struct is a header or container for another struct, which may be one of several different structure types. For example, a binary file may be composed of records, each with an identical header, and one field of that header is the record type, which defines how the remainder of that record should be interpreted.&lt;/p&gt;

&lt;p&gt;For this post, we’ll use the same &lt;code&gt;Data&lt;/code&gt; struct we were working with last time, but this time we want to add some padding between the first and second data fields:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* TODO: forty bytes of padding goes here */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Bonus points if our solution allows accessing that padding as another overlaid struct type.&lt;/p&gt;

&lt;h2 id=&quot;the-ideal-solution-not-supported-safe-fixed-size-buffers&quot;&gt;The Ideal Solution (Not Supported): Safe Fixed-Size Buffers&lt;/h2&gt;

&lt;p&gt;Ideally, we could just define a block of memory in our struct. This is similar to how it’s done in unamanged languages:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// The code below currently causes these compiler erorrs.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Error CS0650 Bad array declarator: To declare a managed array the rank specifier precedes the variable&amp;#39;s identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Error CS0270 Array size cannot be specified in a variable declaration (try initializing with a &amp;#39;new&amp;#39; expression)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s actually been some discussion about adding this to C#; the feature is called “safe fixed-size buffers” (a.k.a., “anonymous inline arrays”). It &lt;a href=&quot;https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#safe-fixed-size-buffers&quot;&gt;didn’t make it into C# 11&lt;/a&gt;. The syntax above &lt;a href=&quot;https://github.com/dotnet/csharplang/issues/1314&quot;&gt;was considered for C# 12&lt;/a&gt; but &lt;a href=&quot;https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-01.md#fixed-size-buffers&quot;&gt;rejected earlier this year&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;inline-arrays-net-80--c-12&quot;&gt;Inline Arrays (.NET 8.0 / C# 12)&lt;/h2&gt;

&lt;p&gt;Even though the nicer syntax above was rejected, &lt;a href=&quot;https://github.com/dotnet/csharplang/blob/f2800749ab171e9d6076f4f4bb5d0513f11c234a/proposals/csharp-12.0/inline-arrays.md&quot;&gt;inline arrays&lt;/a&gt; themselves have been accepted. Indeed, it is possible that a future version of C# may give us the nice syntax above, &lt;a href=&quot;https://github.com/dotnet/csharplang/blob/f2800749ab171e9d6076f4f4bb5d0513f11c234a/proposals/csharp-12.0/inline-arrays.md#detailed-design-option-2&quot;&gt;implemented using inline arrays&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For now, we can just deconstruct that ourselves and write by hand what we wish the compiler would write for us:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Padding40&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;  [InlineArray(40)]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Padding40&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code&gt;InlineArrayAttribute&lt;/code&gt; is a bit odd; what it’s actually doing is telling the runtime to repeat the single field in that struct that many times. So &lt;code&gt;Padding40&lt;/code&gt; is actually 40 bytes long.&lt;/p&gt;

&lt;p&gt;This works fine, as long as you’re on .NET 8.0; the &lt;code&gt;InlineArrayAttribute&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/runtime/issues/61135&quot;&gt;requires runtime support&lt;/a&gt;. If you define your own &lt;code&gt;InlineArrayAttribute&lt;/code&gt; and try to run this on earlier runtimes, the &lt;code&gt;Padding40&lt;/code&gt; struct will be the wrong size, and &lt;code&gt;Data&lt;/code&gt; will not get the correct amount of padding.&lt;/p&gt;

&lt;p&gt;Bonus: we can access the padding as another overlaid struct type by adding this member to the &lt;code&gt;Data&lt;/code&gt; struct:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;na&quot;&gt;[UnscopedRef]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PaddingAs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Padding40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;unsafe-fixed-size-buffers&quot;&gt;Unsafe Fixed-Size Buffers&lt;/h2&gt;

&lt;p&gt;The nicer syntax above is all about taking an existing feature - &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code?WT.mc_id=DT-MVP-5000058#fixed-size-buffers&quot;&gt;unsafe fixed-size buffers&lt;/a&gt; - and allowing them in a safe context. If you’re not on .NET 8.0 yet, you can still use the old-school unsafe fixed-size buffers:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fixed&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This also works fine, but has the drawback of requiring an &lt;code&gt;unsafe&lt;/code&gt; context. The &lt;code&gt;Overlay&lt;/code&gt; helper from the &lt;a href=&quot;/2023/09/memory-mapped-files-overlaid-structs.html&quot;&gt;last post&lt;/a&gt; is also &lt;code&gt;unsafe&lt;/code&gt;, but it would be nice if that was the &lt;em&gt;only&lt;/em&gt; &lt;code&gt;unsafe&lt;/code&gt; thing and all my overlay structures don’t have to be &lt;code&gt;unsafe&lt;/code&gt; just to add padding.&lt;/p&gt;

&lt;p&gt;Bonus: we can access the padding as another overlaid struct type by adding this member to the &lt;code&gt;Data&lt;/code&gt; struct:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PaddingAs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fixed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It does seem a bit awkward to me, though. The &lt;code&gt;fixed&lt;/code&gt; statement is informing the GC that &lt;code&gt;_padding&lt;/code&gt; can’t be moved… but since this is an overlaid structure (at the address of a memory-mapped view), it can’t be moved &lt;em&gt;anyway&lt;/em&gt;. So it seems superfluous. Probably &lt;a href=&quot;https://stackoverflow.com/a/22204244/263693&quot;&gt;not a lot of overhead&lt;/a&gt;; it’s just that the code seems awkward: “pin this thing in memory, read the pointer value, and then unpin it”.&lt;/p&gt;

&lt;h2 id=&quot;explicit-struct-layout&quot;&gt;Explicit Struct Layout&lt;/h2&gt;

&lt;p&gt;Let’s try an old-school, p/Invoke-style approach:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;na&quot;&gt;[StructLayout(LayoutKind.Explicit)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;  [FieldOffset(0)]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;  [FieldOffset(44)]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I was curious to know if this approach worked, and it does. I don’t really recommend it, since you have to explicitly lay out your entire struct. Also, there isn’t a good way of referencing the padding.&lt;/p&gt;

&lt;h2 id=&quot;marshalling-doesnt-work&quot;&gt;Marshalling (Doesn’t Work)&lt;/h2&gt;

&lt;p&gt;Just as a side note, &lt;em&gt;marshalling&lt;/em&gt; directives don’t work. For example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Does not work!&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;[StructLayout(LayoutKind.Sequential)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;  [MarshalAs(UnmanagedType.ByValArray, SizeConst = 40)]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This works if we’re doing p/Invoke, because it’s marshalling (copying) the structure to/from unmanaged code. Since we’re &lt;em&gt;overlaying&lt;/em&gt; the structure directly in memory, marshalling directives like this don’t work.&lt;/p&gt;

&lt;h2 id=&quot;explicit-fields&quot;&gt;Explicit Fields&lt;/h2&gt;

&lt;p&gt;Of course, you can always define padding using multiple explicit fields. The resulting code is ugly (and IMO more awkward to maintain), but it works fine:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’m using &lt;code&gt;int&lt;/code&gt; fields above so I only have to type 10 of them, as opposed to 40 &lt;code&gt;byte&lt;/code&gt;-sized fields.&lt;/p&gt;

&lt;p&gt;You can even do a bonus round with this approach by referencing the first padding member:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;na&quot;&gt;[UnscopedRef]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PaddingAs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_padding0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, if you have lots of padding (or multiple padding sections), this can get tedious.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Since I’m working on a greenfield project, I’ve chosen to use the .NET 8.0-style &lt;code&gt;InlineArrayAttribute&lt;/code&gt; approach, with the hope that the syntax becomes nicer in future versions of C#. If I had to support older .NET versions, I’d probably take the “Unsafe Fixed-Size Buffers” approach, even though it requires &lt;code&gt;unsafe&lt;/code&gt; contexts for all those overlaid structs.&lt;/p&gt;

&lt;p&gt;I hope this has been helpful to you during your memory-mapping adventures!&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2023/10/padding-for-overlaid-structs.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2023/10/padding-for-overlaid-structs.html</guid>
      </item>
    
      <item>
        <title>Memory-Mapped Files and Overlaid Structs</title>
        <description>&lt;p&gt;It has been a long, long time since I’ve used memory-mapped files - I think the last time was before .NET existed (!). Recently, I had a need to work with memory-mapped files in C#, and I gathered together a few resources that explain how to do it - specifically, how to map a file into memory and then “overlay” a structure on top of that memory. Since it took me a while to figure this out (and I learned about some cool upcoming features along the way), I thought I’d write this up into a proper post or two.&lt;/p&gt;

&lt;h2 id=&quot;memory-mapped-files&quot;&gt;Memory-Mapped Files&lt;/h2&gt;

&lt;p&gt;Memory-mapped files are a pretty cool technique, where instead of reading disk data into memory directly, you can &lt;em&gt;map&lt;/em&gt; it into the memory space of your process very quickly. Once it’s mapped into your process memory, reading from that memory will read from the disk (as necessary), and writing to that memory will write out to the file (eventually). You can do cool things like create a huge file mapping (way larger than your memory), and it will Just Work, paging memory in and out of your process behind the scenes. There’s a ton of information about memory-mapped files out there; if you’re on Windows, I like &lt;a href=&quot;https://www.amazon.com/Windows-Internals-Part-architecture-management/dp/0735684189?crid=1R9XTJDVYVT4R&amp;amp;qid=1695906423&amp;amp;linkCode=ll1&amp;amp;tag=stepheclearys-20&amp;amp;linkId=a9d94c8104abdd7c669e33fd6ea2d430&amp;amp;language=en_US&amp;amp;ref_=as_li_ss_tl&quot; rel=&quot;nofollow&quot;&gt;Windows Internals&lt;/a&gt; - Part 1 covers the memory manager (including memory-mapped files), and Part 2 has a few additional details on how memory-mapped files interact with the cache manager.&lt;/p&gt;

&lt;p&gt;In C#, mapping a file into memory isn’t terribly complex. First, you open the file (i.e., create a &lt;code&gt;FileStream&lt;/code&gt; object). Then, you create a file mapping. Tip on the file mapping: if you’re mapping an existing file, you can pass &lt;code&gt;0&lt;/code&gt; for the file length to just map the entire file. Finally, you create a view on that file mapping - and this is the step that actually maps the file into the memory space for your process. You &lt;em&gt;can&lt;/em&gt; create a view over the entire file, but if you’re dealing with a very large file mapping, it’s common to create partial views as you need them.&lt;/p&gt;

&lt;p&gt;This code will create a new file, a file mapping (specifying 1000 bytes as the length of the file; the file is immediately grown to this size), and a single view over the entire file:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;FileStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&amp;quot;tmp.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FileShare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RandomAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedFile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MemoryMappedFileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandleInheritability&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaveOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateViewAccessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, you have a &lt;code&gt;view&lt;/code&gt;, which is a handle (actually a pointer) to the part of your process’ memory that actually represents the file contents. What’s really nice about this code is that it’s portable; the same code works on Linux and Windows (and presumably Mac and mobile platforms, though I haven’t tried those). However, pointers aren’t a great interface, especially in a managed language like C#. &lt;code&gt;MemoryMappedViewAccessor&lt;/code&gt; has a bunch of… well… &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.io.memorymappedfiles.memorymappedviewaccessor?view=net-7.0&amp;amp;WT.mc_id=DT-MVP-5000058#methods&quot;&gt;&lt;em&gt;awkward&lt;/em&gt; methods&lt;/a&gt; that are essentially “read a signed 16-bit integer at this offset”, “write an unsigned 32-bit integer at this offset”, etc. You can also copy a struct into and out of the view, but I don’t want to go through the trouble of doing a file mapping just to turn around and serialize a struct anyway.&lt;/p&gt;

&lt;p&gt;For convenience, unmanaged languages commonly overlay a structure onto the mapped memory. This approach allows you to define the file structure as an actual &lt;code&gt;struct&lt;/code&gt; and then read/write fields in that struct instead of serializing values to memory or view offsets. “Overlapped structures” might be a more common term than “overlaid structures”, but I want to avoid any confusion with &lt;code&gt;OVERLAPPED&lt;/code&gt;, so I’m using the term “overlaid structures” in these posts.&lt;/p&gt;

&lt;p&gt;If you’re in an unmanaged language like C++, you can just &lt;code&gt;reinterpret_cast&lt;/code&gt; your file mapping view pointer to a structure pointer, and that’s it: you’ve got a struct at the same memory address as your file view! I found that there was much less information about overlaying structs in C#, though. So, let’s see how to do the same thing in C#!&lt;/p&gt;

&lt;h2 id=&quot;overlaid-structs&quot;&gt;Overlaid Structs&lt;/h2&gt;

&lt;p&gt;After a bit of experimentation, this is what I ended up with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Overlay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDisposable&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SafeMemoryMappedViewHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AcquirePointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SafeMemoryMappedViewHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleasePointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is an &lt;code&gt;unsafe&lt;/code&gt; type, but ideally this is the only place where &lt;code&gt;unsafe&lt;/code&gt; is necessary.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Overlay&lt;/code&gt; is mainly just a pointer - the pointer to the view of the file that has been mapped into your process’ memory. It also has a &lt;code&gt;MemoryMappedViewAccessor&lt;/code&gt; member, but that’s just used to free the pointer when the &lt;code&gt;Overlay&lt;/code&gt; instance is disposed.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Overlay&lt;/code&gt; has a single notable member: &lt;code&gt;As&amp;lt;T&amp;gt;()&lt;/code&gt;, which allows you to get a reference to a struct that overlays the mapped memory view.&lt;/p&gt;

&lt;div class=&quot;alert alert-info&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-info-circle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;On Windows (at least), the &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt; handle actually &lt;em&gt;is&lt;/em&gt; a pointer, and the &lt;code&gt;AcquirePointer&lt;/code&gt; and &lt;code&gt;ReleasePointer&lt;/code&gt; calls increment and decrement a reference counter for that handle. &lt;code&gt;Overlay&lt;/code&gt; could be designed very differently (and more efficiently) if it cast the &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt; handle value to a pointer.&lt;/p&gt;

  &lt;p&gt;However, on other platforms, I’m not sure if &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt; is actually a pointer or not, so I’ve stuck with this safer implementation just to make sure the code is portable.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;If you are OK with assuming &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt; is a pointer, you can use this instead of &lt;code&gt;Overlay&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemoryMappedViewAccessorExtensions&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SafeMemoryMappedViewHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DangerousGetHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ToPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a fair amount of “unsafe” and “dangerous” in that code, though, and it also makes some implementation assumptions (specifically, that &lt;code&gt;SafeMemoryMappedViewHandle&lt;/code&gt;’s handle is an actual &lt;em&gt;pointer to memory&lt;/em&gt;). So, for safety, I’m just sticking with &lt;code&gt;Overlay&lt;/code&gt; with its explicit &lt;code&gt;AcquirePointer&lt;/code&gt; and &lt;code&gt;ReleasePointer&lt;/code&gt; calls.&lt;/p&gt;

&lt;h2 id=&quot;using-overlay&quot;&gt;Using Overlay&lt;/h2&gt;

&lt;p&gt;First, define your &lt;code&gt;struct&lt;/code&gt; type, keeping in mind that the in-memory layout (including packing/padding) must reflect the on-disk file structure. Then, you can map a file just like the above code, create an &lt;code&gt;Overlay&lt;/code&gt; type, and acquire a struct reference. At that point, you can read or write the struct as desired.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;First&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;FileStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&amp;quot;tmp.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FileShare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RandomAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedFile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MemoryMappedFileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandleInheritability&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaveOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateViewAccessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Overlay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;First&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Run the code above (works in LINQPad!), and you’ll end up with a &lt;code&gt;tmp.dat&lt;/code&gt; file 1000 bytes long, with the first four bytes having the value of &lt;code&gt;First&lt;/code&gt; (1) and the second four bytes having the value of &lt;code&gt;Second&lt;/code&gt; (2). Note that since you’re reading/writing structures in memory, whatever endianness your machine is will determine the endianness of the binary file. Go ahead and pop it open in a hex editor (there’s an online one called &lt;a href=&quot;https://hexed.it/&quot;&gt;HexEd.it&lt;/a&gt;), and take a look at the binary file itself.&lt;/p&gt;

&lt;h2 id=&quot;endianness&quot;&gt;Endianness&lt;/h2&gt;

&lt;p&gt;If you’re working with portable file formats, handling endianness is a necessity. Values in files on disk must be little-endian or big-endian, regardless of what processor happens to be reading or writing them. I recommend handling the differences in code with helpers, like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OverlayHelpers&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReadBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;BitConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLittleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryPrimitives&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseEndianness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WriteBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;bigEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLittleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryPrimitives&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseEndianness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReadLittleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;BitConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLittleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryPrimitives&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseEndianness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WriteLittleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;littleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLittleEndian&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BinaryPrimitives&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseEndianness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The helpers above let you read/write big- or little-endian values, regardless of the endianness of the current machine. They can be used in your structure definitions as such:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Layout&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Convenience accessors&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;First&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverlayHelpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverlayHelpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverlayHelpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OverlayHelpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteBigEndian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now the same program as above will always write the “first” and “second” fields as 32-bit signed big-endian values:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// (this is the same code as above)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;FileStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&amp;quot;tmp.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FileShare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RandomAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedFile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryMappedFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MemoryMappedFileAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandleInheritability&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaveOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MemoryMappedViewAccessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateViewAccessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Overlay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;First&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, the code is completely portable: any .NET runtime that supports memory-mapped files (which AFAIK is all of them) will run this code, giving you the ability to define portable binary file formats using overlaid structures.&lt;/p&gt;

&lt;h2 id=&quot;a-word-of-warning-alignment&quot;&gt;A Word of Warning: Alignment&lt;/h2&gt;

&lt;p&gt;Since you’re overlaying structures directly into memory addresses, you have to handle all the alignment requirements yourself. Some more common architectures such as x86/x64 don’t care about alignment and allow you to, e.g., define an &lt;code&gt;int&lt;/code&gt; field at an offset of &lt;code&gt;1&lt;/code&gt;. Other architectures do not allow unaligned access at all.&lt;/p&gt;

&lt;p&gt;As a general guideline, align your structure members by their own size. E.g., an &lt;code&gt;int&lt;/code&gt; is 4 bytes, so it should be aligned on a 4-byte boundary. Put another way, the offset of an &lt;code&gt;int&lt;/code&gt; field from the beginning of the &lt;code&gt;struct&lt;/code&gt; should be evenly divisible by 4. Same for other types: &lt;code&gt;long&lt;/code&gt; should be aligned on an 8-byte boundary, while &lt;code&gt;byte&lt;/code&gt; should be aligned on a 1-byte boundary (i.e., anywhere).&lt;/p&gt;

&lt;h2 id=&quot;a-word-of-warning-exceptions&quot;&gt;A Word of Warning: Exceptions&lt;/h2&gt;

&lt;p&gt;Memory mapped files give you one kind of convenience by mapping files into memory, but the counterpoint is that I/O exceptions may not happen exactly when you expect them to.&lt;/p&gt;

&lt;p&gt;When reading a file using normal I/O calls, if the read fails, then it fails right at that time. When using memory-mapped files, reads &lt;em&gt;from memory&lt;/em&gt; may cause an I/O exception. This is true even if a previous read from that same memory succeeded.&lt;/p&gt;

&lt;p&gt;Similarly, if you write to a file using normal I/O calls, any failures are reported immediately. With memory-mapped files, &lt;em&gt;memory&lt;/em&gt; writes may cause an I/O exception. And since memory-mapped files are lazily flushed to disk, I/O exceptions may be delayed until the view is flushed (during disposal).&lt;/p&gt;

&lt;h2 id=&quot;next-time&quot;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;I hope this has been helpful! If anyone out there knows a way to eliminate the &lt;code&gt;unsafe&lt;/code&gt; code in &lt;code&gt;Overlay&lt;/code&gt;, I’d love to hear it!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/2023/10/padding-for-overlaid-structs.html&quot;&gt;Next time&lt;/a&gt; I’m planning to write a bit about overlaying structures with holes in them, which is a useful technique when you have “header” or “container” structures that wrap other structures possibly of different types.&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Sep 2023 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2023/09/memory-mapped-files-overlaid-structs.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2023/09/memory-mapped-files-overlaid-structs.html</guid>
      </item>
    
      <item>
        <title>Grounded ChatGPT</title>
        <description>&lt;p&gt;So, there’s this thing you may have heard of called ChatGPT. A lot of people (myself included) have thought “OK, nice toy. It’s pretty good at producing human-sounding text. But I want to run it &lt;em&gt;on my own data&lt;/em&gt; without becoming a data scientist and spending a few hundred thousand dollars in training costs.”&lt;/p&gt;

&lt;p&gt;Then someone pointed out to me there’s already a technique for this called Retrieval Augmented Generation, and in fact there’s some &lt;a href=&quot;https://github.com/Azure-Samples/azure-search-openai-demo&quot;&gt;sample code right there&lt;/a&gt; showing how to do it.&lt;/p&gt;

&lt;h2 id=&quot;retrieval-augmented-generation&quot;&gt;Retrieval Augmented Generation&lt;/h2&gt;

&lt;p&gt;To save you a Google search (or ChatGPT query?), here’s my super-simple description of this technique: when the user asks a question, instead of just giving it to ChatGPT directly, first do a &lt;em&gt;search&lt;/em&gt; for that question over your own data, and combine the search results &lt;em&gt;along with&lt;/em&gt; the user’s question as the ChatGPT input.&lt;/p&gt;

&lt;p&gt;This technique “grounds” ChatGPT, giving it your own data alongside the user’s question. If you structure your input properly, you can influence ChatGPT to produce relevant results, even including source references. With this technique, ChatGPT is able to produce much better results, without the need for training or even fine-tuning the model itself.&lt;/p&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample Code&lt;/h2&gt;

&lt;p&gt;The official sample referenced above is in Python. And I love Python. As a language, I mean. But it’s been… um… 25 years or so since I’ve used it. Definitely rusty. So I decided to write my own sample (heavily influenced by the official one) in C#. And using local Docker containers as much as possible instead of creating a bunch of Azure resources.&lt;/p&gt;

&lt;p&gt;You can find my &lt;a href=&quot;https://github.com/StephenCleary/grounded-chatgpt&quot;&gt;C# Retrieval Augmented Generation code on GitHub&lt;/a&gt;. It’s not production-ready, but it gets the general point across. You can use it pretty easily to “teach” ChatGPT about modern events or your own custom data. It uses Elasticsearch and Seq (both in local Docker containers), preserving its data in local Docker volumes. And it has exhaustive logging out of the box, so you can always review what APIs were called and how exactly they work. My code does use the Azure OpenAI API to talk to ChatGPT, but everything else is in local Docker containers.&lt;/p&gt;

&lt;h2 id=&quot;more-implementation-details&quot;&gt;More Implementation Details&lt;/h2&gt;

&lt;p&gt;When you use this sample code to do a retrieval-augmented generation, what actually happens is this:&lt;/p&gt;

&lt;p&gt;The user’s question is sent to ChatGPT to extract search keywords, using this template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Below is a question asked by the user that needs to be answered by searching.
Generate a search query based on names and concepts extracted from the question.

### Question:
{question}

### Search query:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ChatGPT is pretty good at generating a search query from a user question; I set the &lt;code&gt;temperature&lt;/code&gt; to zero to ensure there’s no randomness in this call.&lt;/p&gt;

&lt;p&gt;Next, this ChatGPT response is sent to Elasticsearch (just as a &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html&quot;&gt;simple query string&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The results of the Elasticsearch search are then formatted and injected into a ChatGPT prompt that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Answer the following question. You may include multiple answers, but each answer may only use the data provided in the References below.
Each Reference has a number followed by tab and then its data.
Use square brakets to indicate which Reference was used, e.g. [7]
Don't combine References; list each Reference separately, e.g. [1][2]
If you cannot answer using the References below, say you don't know. Only provide answers that include at least one Reference name.
If asking a clarifying question to the user would help, ask the question.
Do not comment on unused References.

### References:
{sources}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result is then post-processed to extract the quoted references and change them to hyperlinks.&lt;/p&gt;

&lt;h2 id=&quot;have-fun&quot;&gt;Have Fun!&lt;/h2&gt;

&lt;p&gt;I’ve been pretty pleased with the results, even though I’m using very simplistic source processing, and a lexical search instead of a more proper semantic/vector search. Even with those limitations, the results are pretty impressive!&lt;/p&gt;

&lt;p&gt;That’s all I have to say for now. Have fun!&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2023/05/grounded-chatgpt.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2023/05/grounded-chatgpt.html</guid>
      </item>
    
      <item>
        <title>Modern C# Techniques, Part 3: Generic Code Generation</title>
        <description>&lt;p&gt;This technique really excites me! We’re in for a good ride today…&lt;/p&gt;

&lt;h2 id=&quot;c-templates-and-code-generation&quot;&gt;C++ Templates and Code Generation&lt;/h2&gt;

&lt;p&gt;Before we take a look at C# generics, first I’ll take a brief look at how C++ templates are used for code generation.&lt;/p&gt;

&lt;p&gt;Templates (and generics) are both forms of polymorphic functions; that is, you define one type (or method) that takes a type parameter, and the generic type/method is able to change its behavior based on the type passed in.&lt;/p&gt;

&lt;p&gt;C++ templates are purely a compile-time construct; they instruct the compiler how to generate the code for the template type/method. Specifically, the compiler performs a transformation called &lt;a href=&quot;https://en.wikipedia.org/wiki/Monomorphization&quot;&gt;monomorphization&lt;/a&gt;; for each of the template arguments actually passed to the type/method, the compiler generates a new copy of the type/method specifically for that template argument.&lt;/p&gt;

&lt;p&gt;Monomorphization is what enables C++ templates to be used as code generators.&lt;/p&gt;

&lt;h2 id=&quot;c-generics&quot;&gt;C# Generics&lt;/h2&gt;

&lt;p&gt;C# generics are a run-time construct; the compiler actually outputs the generic type/method itself into the IL (intermediate language). At runtime, the implementation of a generic type/method is shared between the generic arguments.&lt;/p&gt;

&lt;p&gt;In other words, C# generics do &lt;em&gt;not&lt;/em&gt; undergo monomorphization… except…&lt;/p&gt;

&lt;h3 id=&quot;generics-and-value-types&quot;&gt;Generics and Value Types&lt;/h3&gt;

&lt;p&gt;…except when used with value types!&lt;/p&gt;

&lt;p&gt;C# generics do &lt;em&gt;not&lt;/em&gt; undergo monomorphization for reference types; there’s only one copy of the type/method implementation that is shared between all reference types. However, C# generics &lt;em&gt;do&lt;/em&gt; undergo monomorphization for value types!&lt;/p&gt;

&lt;p&gt;This makes sense; if a method &lt;code&gt;Something&amp;lt;T&amp;gt;&lt;/code&gt; defines a local variable &lt;code&gt;T value;&lt;/code&gt;, the compiler needs to know how big that &lt;code&gt;T&lt;/code&gt; is. The size of a reference is the same regardless of the type being referred to, but the size of value type values can vary.&lt;/p&gt;

&lt;p&gt;So, it turns out that C# generics &lt;em&gt;do&lt;/em&gt; have monomorphization. They just don’t do it for &lt;em&gt;all&lt;/em&gt; generic arguments, only the ones that are value types. And monomorphization isn’t done by the C# compiler; it’s done by the JIT compiler (at runtime).&lt;/p&gt;

&lt;h3 id=&quot;generics-and-constrained-value-types&quot;&gt;Generics and Constrained Value Types&lt;/h3&gt;

&lt;p&gt;Monomorphization is fine for &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; and friends, which don’t actually &lt;em&gt;do&lt;/em&gt; anything with the &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For code generation, though, monomorphization is most useful if you also constrain the generics to a specific interface. A simple (and rather silly) example will make this more clear:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;interface ISample
{
  int Setting { get; }
}

void Function&amp;lt;T&amp;gt;()
    where T : struct, ISample
{
  if (default(T).Setting == 13)
    Console.WriteLine(&quot;Ah, my favorite number!&quot;);
  else
    Console.WriteLine($&quot;You passed {default(T).Setting}.&quot;);
}

readonly struct Sample7 : ISample
{
  public int Setting =&amp;gt; 7;
}

readonly struct Sample13 : ISample
{
  public int Setting =&amp;gt; 13;
}

Function&amp;lt;Sample7&amp;gt;();
Function&amp;lt;Sample13&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The C# compiler just treats &lt;code&gt;Function&lt;/code&gt; like an ordinary generic function. The JIT compiler will create &lt;em&gt;two separate copies&lt;/em&gt; of &lt;code&gt;Function&lt;/code&gt;; because &lt;code&gt;Sample7&lt;/code&gt; and &lt;code&gt;Sample13&lt;/code&gt; are both value types, monomorphization occurs and the JIT compiler generates &lt;em&gt;two&lt;/em&gt; copies of the method. In both copies, the &lt;code&gt;default(T).Setting&lt;/code&gt; code is emmitted as a constrained virtual call.&lt;/p&gt;

&lt;p&gt;Then, each copy of the method has a high likelihood of being optimized. After all, the compiler knows the type of &lt;code&gt;T&lt;/code&gt; for each copy. When it optimizes &lt;code&gt;Function&amp;lt;Sample7&amp;gt;&lt;/code&gt;, it &lt;em&gt;knows&lt;/em&gt; that the &lt;code&gt;default(T).Setting&lt;/code&gt; is calling the &lt;code&gt;ISample.get_Setting&lt;/code&gt; method on the &lt;code&gt;Sample7&lt;/code&gt; type. The &lt;code&gt;Sample7&lt;/code&gt; implementation of &lt;code&gt;ISample.Setting&lt;/code&gt; is trivial and is likely going to be inlined, which means that the &lt;code&gt;if&lt;/code&gt; branch can be precomputed. It is extremely likely that both copies of &lt;code&gt;Function&amp;lt;T&amp;gt;&lt;/code&gt; only end up having a single &lt;code&gt;Console.WriteLine&lt;/code&gt; call, without any &lt;code&gt;if&lt;/code&gt; statement at all!&lt;/p&gt;

&lt;p&gt;At this point, we have real code generation using C# generics!&lt;/p&gt;

&lt;h3 id=&quot;generics-and-constrained-value-types-with-static-abstract-interface-methods&quot;&gt;Generics and Constrained Value Types with Static Abstract Interface Methods&lt;/h3&gt;

&lt;p&gt;Static abstract interface methods allow us to clean this up even a bit more. Instead of defining &lt;code&gt;Setting&lt;/code&gt; as an instance method, it can now be a static method, as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;interface ISample
{
  static abstract int Setting { get; }
}

void Function&amp;lt;T&amp;gt;()
    where T : struct, ISample
{
  if (T.Setting == 13)
    Console.WriteLine(&quot;Ah, my favorite number!&quot;);
  else
    Console.WriteLine($&quot;You passed {T.Setting}.&quot;);
}

readonly struct Sample7 : ISample
{
  public static int Setting =&amp;gt; 7;
}

readonly struct Sample13 : ISample
{
  public static int Setting =&amp;gt; 13;
}

Function&amp;lt;Sample7&amp;gt;();
Function&amp;lt;Sample13&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now there’s no need for a &lt;code&gt;default(T)&lt;/code&gt; value inside &lt;code&gt;Function&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;warnings-and-limitations&quot;&gt;Warnings and Limitations&lt;/h2&gt;

&lt;p&gt;By using C# generics with value types, we can ensure monomorphization takes place; however, the rest of the behavior is not guaranteed.&lt;/p&gt;

&lt;h3 id=&quot;no-guarantees&quot;&gt;No Guarantees&lt;/h3&gt;

&lt;p&gt;The JIT compiler doesn’t actually &lt;em&gt;guarantee&lt;/em&gt; that any particular methods are inlined, or that any kind of optimization takes place (e.g., removing the &lt;code&gt;if&lt;/code&gt; statement in our example). It’s reasonable to assume that &lt;em&gt;some&lt;/em&gt; optimization will take place, and with modern tiered optimization, you can also expect that the method will become &lt;em&gt;more&lt;/em&gt; optimized if it is called a lot.&lt;/p&gt;

&lt;p&gt;With C++ templates (and other compile-time-only monomorphization systems), you can &lt;em&gt;know&lt;/em&gt; that the resulting code will be fully optimized. With C# generics, the optimization happens at runtime, so the runtime has to balance between executing the code &lt;em&gt;now&lt;/em&gt; and speeding it up for &lt;em&gt;later&lt;/em&gt;. At the end of the day, the best you can do is hope.&lt;/p&gt;

&lt;h3 id=&quot;limited-to-interfaces&quot;&gt;Limited to Interfaces&lt;/h3&gt;

&lt;p&gt;When doing this kind of code generation, you’re limited to only what can be expressed as interface members. You can define methods and properties, but not &lt;code&gt;const&lt;/code&gt; values or nested types. It’s not a &lt;em&gt;complete&lt;/em&gt; code generation solution like C++ templates, but it’s certainly useful nonetheless.&lt;/p&gt;

&lt;h2 id=&quot;applications&quot;&gt;Applications&lt;/h2&gt;

&lt;h3 id=&quot;more-efficient-general-algortihms&quot;&gt;More Efficient General Algortihms&lt;/h3&gt;

&lt;p&gt;There are some algorithms that take parameters that often don’t change for a given program. To take an example I’m familiar with, CRC32 hashes are actually a &lt;em&gt;class&lt;/em&gt; of hash algorithms with different values for polynomials, initializers, and a few other parameters. Usually, a program that uses a CRC32 hash only uses &lt;em&gt;one&lt;/em&gt; of these algorithms (one specific polynomial with a specific initializer value, etc). If the CRC32 implementation uses code generation, that will allow the JIT compiler to optimize just for that specific CRC32 hash algorithm.&lt;/p&gt;

&lt;h3 id=&quot;more-general-algortihms&quot;&gt;More General Algortihms&lt;/h3&gt;

&lt;p&gt;It’s also possible to make one algorithm even more generic, especially due to the static interface methods. For a similar example to the above, CRC16 is &lt;em&gt;another&lt;/em&gt; class of hash algorithms that is practically the same as CRC32 except it uses 16-bit integers instead of 32-bit integers. Static interface methods would allow a single unified “CRC” algorithm that can handle &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members?WT.mc_id=DT-MVP-5000058#generic-math&quot;&gt;any numeric type with generic math constraints&lt;/a&gt;. So our CRC32 and CRC16 implementations can be combined.&lt;/p&gt;

&lt;h3 id=&quot;replacing-constant-arguments&quot;&gt;Replacing Constant Arguments&lt;/h3&gt;

&lt;p&gt;There are a few situations in code where certain method arguments are always constant values. This is usually an indication that the method should be split into two methods, but sometimes there are maintenance concerns that are sufficiently strong, keeping the methods as a single implementation.&lt;/p&gt;

&lt;p&gt;The example that I’m most familiar with here is the &lt;a href=&quot;https://learn.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development?WT.mc_id=DT-MVP-5000058#the-flag-argument-hack&quot;&gt;boolean argument hack&lt;/a&gt; for providing both synchronous and asynchronous versions of a method, which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;private async Task&amp;lt;string&amp;gt; GetCoreAsync(bool sync)
{
  if (sync)
    Thread.Sleep(TimeSpan.FromSeconds(1));
  else
    await Task.Delay(TimeSpan.FromSeconds(1));
  return &quot;Hi!&quot;;
}

public string Get() =&amp;gt; GetCoreAsync(sync: true).GetAwaiter().GetResult();
public Task&amp;lt;string&amp;gt; GetAsync() =&amp;gt; GetCoreAsync(sync: false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above, &lt;code&gt;GetCoreAsync&lt;/code&gt; has a &lt;code&gt;sync&lt;/code&gt; argument that is &lt;em&gt;always&lt;/em&gt; a constant. Really, it &lt;em&gt;should&lt;/em&gt; be two different methods, but if we pretend that &lt;code&gt;GetCoreAsync&lt;/code&gt; is much longer and more complex, then making it two different methods does cause a maintenance burden.&lt;/p&gt;

&lt;p&gt;So, let’s use generic code generation to &lt;em&gt;generate&lt;/em&gt; two different methods!&lt;/p&gt;

&lt;p&gt;First, we’d extract the code differences (&lt;code&gt;Thread.Sleep&lt;/code&gt; vs &lt;code&gt;Task.Delay&lt;/code&gt;). These are going to need a definition in our interface, and they’ll be implemented by each value type. Since we’re talking about code that may be synchronous or asynchronous, we’ll use value tasks as the return type. (Reminder: any time you have a method whose implementation &lt;em&gt;may&lt;/em&gt; be asynchronous, then it should have an asynchronous signature). Then, &lt;code&gt;GetCoreAsync&lt;/code&gt; can just invoke those interface methods. We end up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;private interface IDelay
{
  static abstract ValueTask DelayAsync(TimeSpan delay);
}

private readonly struct SynchronousDelay : IDelay
{
  static ValueTask DelayAsync(TimeSpan delay)
  {
    Thread.Sleep(delay);
    return new();
  }
}

private readonly struct AsynchronousDelay : IDelay
{
  static async ValueTask DelayAsync(TimeSpan delay) =&amp;gt; await Task.Delay(delay);
}

private async Task&amp;lt;string&amp;gt; GetCoreAsync&amp;lt;TDelay&amp;gt;()
    where TDelay: struct, IDelay
{
  await TDelay.DelayAsync(TimeSpan.FromSeconds(1));
  return &quot;Hi!&quot;;
}

public string Get() =&amp;gt; GetCoreAsync&amp;lt;SynchronousDelay&amp;gt;().GetAwaiter().GetResult();
public Task&amp;lt;string&amp;gt; GetAsync() =&amp;gt; GetCoreAsync&amp;lt;AsynchronousDelay&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The core implementation (&lt;code&gt;GetCoreAsync&lt;/code&gt;) is simplified and is more obviously correct. The public interface (&lt;code&gt;Get&lt;/code&gt; and &lt;code&gt;GetAsync&lt;/code&gt;) didn’t change at all. And at runtime, if only one path is used, then only one path will be JITted. If both paths are used, then two copies of &lt;code&gt;GetCoreAsync&lt;/code&gt; are created by the JITter, each one optimized for its own situation (asynchronous or synchronous). This is a particularly useful technique for libraries, which may need to provide both forms of methods, but have a high likelihood of only one of them being used.&lt;/p&gt;

&lt;p&gt;Stephen Toub discusses how the BCL uses this technique &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/?WT.mc_id=DT-MVP-5000058#:~:text=One%20final%20change%20related%20to%20reading%20and%20writing%20performance&quot;&gt;in a recent blog post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Generic code generation provides a limited form of code generation in C#, because value types cause monomorphization. Static interface members provide an even nicer way to do generic code generation.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/10/modern-csharp-techniques-3-generic-code-generation.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/10/modern-csharp-techniques-3-generic-code-generation.html</guid>
      </item>
    
      <item>
        <title>Modern C# Techniques, Part 2: Value Records</title>
        <description>&lt;p&gt;Today I’ll cover another technique for modern C# that isn’t exactly &lt;em&gt;new&lt;/em&gt;, but which the language supports much better than it used to.&lt;/p&gt;

&lt;p&gt;I’m calling today’s technique Value Records, which are a form of the more general “value object” pattern that is specific to modern C#. But before we dive into the solution, let’s look at the problem.&lt;/p&gt;

&lt;h2 id=&quot;primitive-obsession&quot;&gt;Primitive Obsession&lt;/h2&gt;

&lt;p&gt;The name of the antipattern we’re trying to remove is Primitive Obsession. This is a highly searchable term with some great descriptions out there.&lt;/p&gt;

&lt;p&gt;Essentially, Primitive Obsession is when a developer (over)uses primitives (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;Guid&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, etc) to represent business or domain concepts. One classic example is entity ids. There are a couple of problems with using primitives like this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The primitives are not type-safe. In other words, it’s easy to accidentally pass a &lt;code&gt;customerId&lt;/code&gt; to a method expecting a &lt;code&gt;resourceId&lt;/code&gt;. Or, say, if a method needs &lt;em&gt;both&lt;/em&gt; a &lt;code&gt;customerId&lt;/code&gt; and &lt;code&gt;resourceId&lt;/code&gt;, it’s easy to pass the parameters in the wrong order.&lt;/li&gt;
  &lt;li&gt;Primitives support operations that don’t make sense. For example, if a &lt;code&gt;customerId&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt;, the compiler will happily let you divide it by 2, but that makes no business sense at all. A related problem is when you have &lt;em&gt;units&lt;/em&gt;, such as &lt;code&gt;distanceInFeet&lt;/code&gt; and &lt;code&gt;distanceInMeters&lt;/code&gt;; the lack of units in the type system allow these values to be (incorrectly) added together.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;solving-primitive-obsession-with-value-objects&quot;&gt;Solving Primitive Obsession with Value Objects&lt;/h2&gt;

&lt;p&gt;Value Objects are the general solution to Primitive Obsession. The idea is that you define a (simple) domain object that wraps the primitive type inside a type-safe wrapper type. In some cases, this wrapper type may have some limited domain behavior (such as validation), but in many cases Value Objects are so-called “anemic domain models”, and that’s OK. Value Objects inhabit a middle ground between primitives and full-blown domain objects.&lt;/p&gt;

&lt;p&gt;Value Objects tend to behave similarly to the primitives they replace:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Value Objects are usually immutable.&lt;/li&gt;
  &lt;li&gt;Value Objects usually have value semantics.&lt;/li&gt;
  &lt;li&gt;If a primitive has a useful operation (e.g., string concatenation, integer addition, or even &lt;code&gt;ToString&lt;/code&gt; or &lt;code&gt;GetHashCode&lt;/code&gt; support) that also makes sense for the domain object, then Value Objects usually support those operations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Following these patterns allows Value Objects to essentially be type-safe replacements for primitives. Occasionally some business rules are added (e.g., validation), but just plain old Value Objects work quite well on their own, too.&lt;/p&gt;

&lt;h2 id=&quot;c-and-value-records&quot;&gt;C# and Value Records&lt;/h2&gt;

&lt;p&gt;The modern C# technique for Value Objects is what I call Value Records, and looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;public readonly record struct CustomerId(string Value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, that’s the whole type.&lt;/p&gt;

&lt;p&gt;Breaking it down:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Records provide value semantics, complete with equality, hash code, and &lt;code&gt;ToString&lt;/code&gt; support.&lt;/li&gt;
  &lt;li&gt;Struct records provide a value-type wrapper, avoiding heap allocation (the size of the wrapper &lt;em&gt;is&lt;/em&gt; the size of the wrapped value).&lt;/li&gt;
  &lt;li&gt;Readonly struct records provide immutability.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I prefer to use a single property named &lt;code&gt;Value&lt;/code&gt;, which is similar to &lt;code&gt;Nullable&amp;lt;T&amp;gt;.Value&lt;/code&gt;, except a Value Record &lt;em&gt;always&lt;/em&gt; has a valid &lt;code&gt;Value&lt;/code&gt;. Since the type definition is just a single line, it seems silly to have them follow the one-type-per-file rule; I tend to collect Value Record types and include them in a single source file, usually called &lt;code&gt;Primitives.cs&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;guidelines-for-use&quot;&gt;Guidelines for Use&lt;/h2&gt;

&lt;h3 id=&quot;avoid-sharp-edges&quot;&gt;Avoid Sharp Edges&lt;/h3&gt;

&lt;p&gt;I’ve used Value Records in a few projects now, and I think they work best as internal types. I don’t mean &lt;code&gt;internal&lt;/code&gt;; I mean as types that are created and unwrapped by your own code at the “edges” of your app. Then the core of your app &lt;em&gt;only&lt;/em&gt; deals with the Value Records.&lt;/p&gt;

&lt;p&gt;This way you don’t have to deal with any kind of serialization, which can be a real headache. I recommend you completely ignore Newtonsoft.Json / System.Text.Json / Xml, ASP.NET parameter binding / output formatting, WPF bindings, Entity Framework value conversions, and all other forms of serialization. Instead of trying to automatically support these, just have your own code create the Value Record wrappers when reading the values from an external source (e.g., &lt;code&gt;CustomerId customerId = new(customerIdIntValue)&lt;/code&gt;), and unwrap them when writing values to an external source (e.g., &lt;code&gt;int customerIdIntValue = customerId.Value;&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;choosing-primitives-to-replace&quot;&gt;Choosing Primitives to Replace&lt;/h3&gt;

&lt;p&gt;Not all primitives &lt;em&gt;need&lt;/em&gt; to be Value Records. Choosing which primitives &lt;em&gt;should&lt;/em&gt; be Value Records is a skill, one which everyone is developing right now, and there are no masters of this skill yet AFAIK.&lt;/p&gt;

&lt;p&gt;In my experience, I would say to use primitives by default, but use Value Records in the following situations:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Use Value Records whenever you have similar value types that are used together.
    &lt;ul&gt;
      &lt;li&gt;“Similar” here can mean &lt;em&gt;conceptually&lt;/em&gt; similar or just having a similar &lt;em&gt;name&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Use Value Records whenever you have to &lt;em&gt;guarantee&lt;/em&gt; that a critical value type &lt;em&gt;must&lt;/em&gt; be used only in a particular way.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The classic example of the first situation (similar types) is using Value Records for entity identifiers (&lt;code&gt;CustomerId&lt;/code&gt; and friends). Entity identifiers are conceptually similar &lt;em&gt;and&lt;/em&gt; have similar names, and usually there are multiple methods that deal with different kinds of identifiers at the same time.&lt;/p&gt;

&lt;p&gt;The second situation (critical types) is more of a judgement call. I can at least give an example, though: one of my projects sends emails to users, but also has to deal with users that type in an email address that may or may not be theirs. And there are some severe repercussions for sending emails to people who haven’t asked for them; there’s actual laws in my country about that kind of behavior. So, I created a &lt;code&gt;ValidatedEmail&lt;/code&gt; Value Record for this critical type. In my model, a user has a &lt;code&gt;ValidatedEmail&lt;/code&gt; (whose value may be &lt;code&gt;null&lt;/code&gt;), and the code component that sends emails &lt;em&gt;only&lt;/em&gt; accepts a &lt;code&gt;ValidatedEmail&lt;/code&gt;. It’s comforting to know that the type system itself is enforcing the business rule “only send emails to validated email addresses”.&lt;/p&gt;

&lt;h2 id=&quot;misuse&quot;&gt;Misuse&lt;/h2&gt;

&lt;p&gt;Similar to last week’s technique, the primary misuse of the Value Record technique is &lt;em&gt;overuse&lt;/em&gt;. Once you start feeling the benefits of the stronger type safety from Value Records, you’ll start wanting it everywhere. You may end up temporarily suffering from “Primitive Obsession Obsession”, if you will.&lt;/p&gt;

&lt;p&gt;There’s a maintenance tradeoff with using Value Records: Value Records increase the code complexity. Speficially, Value Records increase the mental burden when reading the code. Put simply: every developer knows what a &lt;code&gt;string&lt;/code&gt; is, but if they see a &lt;code&gt;CustomerId&lt;/code&gt; type, then they need to look that up. Remember, techniques like Value Records are easy to write because they’re in &lt;em&gt;your&lt;/em&gt; head &lt;em&gt;now&lt;/em&gt;, but the resulting code is more difficult to maintain (whether maintained by &lt;em&gt;others&lt;/em&gt; or yourself &lt;em&gt;later&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;After all, it’s not like primitives are evil or anything like that. Primitives are a perfectly fine solution for a lot of data. &lt;code&gt;string CustomerName&lt;/code&gt; is probably just fine; it wouldn’t have any real validation and is unlikely to be confused with something else. Well, that’s true unless your domain has a ton of “names”, in which case maybe it &lt;em&gt;can&lt;/em&gt; be easily confused with another kind of name and &lt;em&gt;should&lt;/em&gt; be a Value Record.&lt;/p&gt;

&lt;h2 id=&quot;history&quot;&gt;History&lt;/h2&gt;

&lt;p&gt;Until records were added to the language, immutable objects were always a bit of a pain, with some going so far as to &lt;a href=&quot;https://github.com/AArnott/ImmutableObjectGraph&quot;&gt;create libraries just to help write immutable types&lt;/a&gt;. The Value Object pattern was used only when absolutely necessary, since it resulted in much more complex code (with a naturally higher probability of containing bugs).&lt;/p&gt;

&lt;p&gt;If you haven’t read it yet, &lt;a href=&quot;https://andrewlock.net/series/using-strongly-typed-entity-ids-to-avoid-primitive-obsession/&quot;&gt;Andrew Lock has a great blog series on using strongly-typed entity IDs to avoid primitive obsession&lt;/a&gt;. I think overall it’s a good series conceptually, but do note that the implementation details are quite dated at this point. Also note how much the complexity is increased by trying to handle only a couple forms of serialization.&lt;/p&gt;

&lt;p&gt;Record types brought immutability to C# as a first-class citizen. The initial record types were class records (reference types), which works great for many immutable types, but tends to be a heavyweight solution for Value Objects. E.g., when wrapping &lt;code&gt;int&lt;/code&gt; values, a &lt;code&gt;class record&lt;/code&gt; wrapper essentially acts as an always-boxed &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These days we have readonly struct records, which are immutable &lt;em&gt;and&lt;/em&gt; lightweight, and a perfect fit for the Value Object pattern.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Carefully replacing some primitive types with Value Records will increase the type safety, correctness, and maintainability of your code.&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Oct 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/10/modern-csharp-techniques-2-value-records.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/10/modern-csharp-techniques-2-value-records.html</guid>
      </item>
    
      <item>
        <title>Modern C# Techniques, Part 1: Curiously Recurring Generic Pattern</title>
        <description>&lt;p&gt;I’m starting a new series today looking at some modern C# techniques. Part of what I like about C# is that the language is always improving, and those improvements bring newer code patterns with them.&lt;/p&gt;

&lt;p&gt;Today’s topic is not actually &lt;em&gt;new&lt;/em&gt;, but many developers haven’t seen it before, so it’s worth taking a look at. As with many of the techniques I’ll be discussing, I’m not sure if this one has a name, so I am just calling it whatever I call it in my head.&lt;/p&gt;

&lt;h2 id=&quot;the-curiously-recurring-generic-pattern&quot;&gt;The Curiously Recurring Generic Pattern&lt;/h2&gt;

&lt;div class=&quot;alert alert-info&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;The “curious” name for this pattern comes from the C++ world, where it was called the Curiously Recurring Template Pattern. So in C# I just call it the Curiously Recurring Generic Pattern, since it’s essentially the same thing but with generics instead of templates. &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot; class=&quot;alert-link&quot;&gt;According to Wikipedia&lt;/a&gt;, it’s actually “F-bound polymorphism”, but I’m not going to remember that.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;The Curiously Recurring Generic Pattern is when an interface (or base type) takes a generic parameter that is its own derived type. A simple example looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;interface IExample&amp;lt;TDerived&amp;gt;
{
}

class MyExample : IExample&amp;lt;MyExample&amp;gt;
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;but-why-tho&quot;&gt;But Why Tho?&lt;/h2&gt;

&lt;p&gt;It essentially comes down to typing. If an interface (or base type) wants to use the &lt;em&gt;full, derived type&lt;/em&gt; as a method parameter or return value, then it can define those methods itself without putting any burdern on the derived type.&lt;/p&gt;

&lt;p&gt;Consider a familiar example from the .NET BCL: &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1?view=net-6.0&amp;amp;WT.mc_id=DT-MVP-5000058&quot;&gt;is defined&lt;/a&gt; as thus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;public interface IEquatable&amp;lt;T&amp;gt;
{
  bool Equals(T? other);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is used as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;sealed class MyEquatable : IEquatable&amp;lt;MyEquatable&amp;gt;
{
  public bool Equals(MyEquatable? other) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The thing to note here is that &lt;code&gt;MyEquatable.Equals&lt;/code&gt; implements &lt;code&gt;IEquatable&amp;lt;T&amp;gt;.Equals&lt;/code&gt; with a &lt;em&gt;strongly-typed&lt;/em&gt; &lt;code&gt;MyEquatable&lt;/code&gt; argument. If the Curiously Recurring Generic Pattern wasn’t used, then &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt; would just be &lt;code&gt;IEquatable&lt;/code&gt; (taking an &lt;code&gt;object&lt;/code&gt; argument), losing type safety and efficiency.&lt;/p&gt;

&lt;h2 id=&quot;adding-a-generic-constraint&quot;&gt;Adding a Generic Constraint&lt;/h2&gt;

&lt;p&gt;The interface (or base type) may also use itself as a generic constraint. It doesn’t &lt;em&gt;have&lt;/em&gt; to (the examples above don’t), but sometimes it’s useful, particularly for base types. The Curiously Recurring Generic Pattern with generic constraints looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;abstract class ExampleBase&amp;lt;TDerived&amp;gt;
    where TDerived : ExampleBase&amp;lt;TDerived&amp;gt;
{
  // Methods in here can use `(TDerived)this` freely.
  // This is particularly useful if this interface wants to *return* a value of TDerived.
  public virtual TDerived Something() =&amp;gt; (TDerived)this;
}

class AnotherExample : ExampleBase&amp;lt;AnotherExample&amp;gt;
{
  // Implicitly has `public AnotherExample Something();` defined.
  // The base class method already has the correct return type.
  // (Can still override if desired).
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As noted in the comments above, this approach is useful if &lt;code&gt;TDerived&lt;/code&gt; is used as a &lt;em&gt;return&lt;/em&gt; type. As one example, this is common with fluent APIs.&lt;/p&gt;

&lt;p&gt;More generally, the generic constraint is needed in either of these situations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The base type needs to treat a &lt;code&gt;ExampleBase&amp;lt;TDerived&amp;gt;&lt;/code&gt; instance (e.g., &lt;code&gt;this&lt;/code&gt;) as its derived type (i.e., &lt;code&gt;(TDerived)this&lt;/code&gt;). This can also come up when passing &lt;code&gt;this&lt;/code&gt; to other methods.&lt;/li&gt;
  &lt;li&gt;The base type needs to treat a &lt;code&gt;TDerived&lt;/code&gt; as a &lt;code&gt;ExampleBase&amp;lt;TDerived&amp;gt;&lt;/code&gt;, e.g., calling private base methods on an instance of type &lt;code&gt;TDerived&lt;/code&gt; &lt;em&gt;other&lt;/em&gt; than &lt;code&gt;this&lt;/code&gt;. In this case no explicit cast is necessary.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;crgp-and-default-interface-methods&quot;&gt;CRGP and Default Interface Methods&lt;/h2&gt;

&lt;p&gt;Similar to regular interface methods, the Curiously Recurring Generic Pattern can enhance the type safety of &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods?WT.mc_id=DT-MVP-5000058&quot;&gt;default interface methods&lt;/a&gt; if necessary. This is similar to using CRGP with base types, except interfaces cannot have state. Put another way, this enables strongly-typed traits, but falls short of mixins.&lt;/p&gt;

&lt;h2 id=&quot;crgp-and-static-interface-methods-and-operators&quot;&gt;CRGP and Static Interface Methods (and Operators)&lt;/h2&gt;

&lt;p&gt;One possibility for CRGP with &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members?WT.mc_id=DT-MVP-5000058&quot;&gt;static interface methods&lt;/a&gt; is to define operators (or other static methods) with the proper type signatures. Previously, CRGP required a base type to define operators (e.g., &lt;a href=&quot;https://github.com/StephenCleary/Comparers/blob/48cd202db5d7ea7209cc4248bf6a531d3752f170/src/Nito.Comparers.Core/EquatableBaseWithOperators.cs&quot;&gt;&lt;code&gt;EquatableBaseWithOperators&amp;lt;TDerived&amp;gt;&lt;/code&gt; in my Nito.Comparers library&lt;/a&gt;), but using CRGP with static interface methods allows strong typing for operator signatures (e.g., &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.numerics.iunarynegationoperators-2?view=net-7.0&amp;amp;WT.mc_id=DT-MVP-5000058&quot;&gt;&lt;code&gt;IUnaryNegationOperators&amp;lt;TSelf, TResult&amp;gt;&lt;/code&gt;&lt;/a&gt; is an interface that defines &lt;code&gt;operator-&lt;/code&gt; with the proper type signature).&lt;/p&gt;

&lt;h2 id=&quot;misuse&quot;&gt;Misuse&lt;/h2&gt;

&lt;p&gt;Like other code patterns, the CRGP can be misused. IMO the most common misuse of this pattern is &lt;em&gt;overuse&lt;/em&gt;. Bear in mind CRGP isn’t powerful enough to provide mixins - even with default interface methods (which provide traits, not mixins).&lt;/p&gt;

&lt;p&gt;Also, CRGP tends to make the code more complex. There’s a tradeoff there, and you need to keep maintainability in mind.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;The Curiously Recurring Generic Pattern isn’t actually new, and it isn’t often necessary, but it’s a nice tool to have when you do need it.&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 4: Polling</title>
        <description>&lt;p&gt;So far in this series, I’ve talked about how to request and detect cancellation, but for the next couple of posts I’ll be switching perspectives and discussing ways to respond to cancellation.&lt;/p&gt;

&lt;p&gt;I know I’ve probably said this a half dozen times already, but it bears repeating: cancellation is cooperative. Your code will be provided a &lt;code&gt;CancellationToken&lt;/code&gt;, and it must &lt;em&gt;do&lt;/em&gt; something with that &lt;code&gt;CancellationToken&lt;/code&gt; in order to be cancelable. Most of the time, this is just passing the &lt;code&gt;CancellationToken&lt;/code&gt; down to lower-level APIs, but if you want cancelable code at the lowest level, there are a couple of other options. The one we’re looking at today is polling.&lt;/p&gt;

&lt;h2 id=&quot;how-to-poll&quot;&gt;How to Poll&lt;/h2&gt;

&lt;p&gt;The normal pattern is to periodically call &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do synchronous work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The example code above checks the cancellation token &lt;em&gt;before&lt;/em&gt; it starts work, which is a good general practice. It is possible that the token is already cancelled by the time your operation starts running.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; will check to see if cancellation is requested, and if it is, it will throw &lt;code&gt;OperationCanceledException&lt;/code&gt;. So it handles the proper reporting of cancellation for you; your code should just let that exception propagate out of the method.&lt;/p&gt;

&lt;p&gt;One question you’ll need to answer is how &lt;em&gt;often&lt;/em&gt; to poll. There really isn’t a good answer for this; ideally you probably want to poll a few times a second, but when you’re talking about CPU-bound code running on potentially very different machines, it’s pretty much a guess at where in the code the &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; should go. Just put it in the best place(s), run some tests to see if cancellation feels responsive enough, and that’s the best you can do.&lt;/p&gt;

&lt;h2 id=&quot;how-not-to-poll&quot;&gt;How Not to Poll&lt;/h2&gt;

&lt;p&gt;There’s a sadly common antipattern regarding polling for cancellation, particularly in infinite loops: the “while not cancelled” loop, which looks like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingForever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FailFast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Bad code! Do not use!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When this code runs, it will periodically check the cancellation token; but when cancellation is requested, the method just returns early. This method doesn’t satisfy the cancellation contract of throwing an exception on cancellation. This means that the calling code cannot know whether the method ran to completion or whether it was cancelled.&lt;/p&gt;

&lt;p&gt;The proper solution is to use &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt;, even for infinite loops:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingForever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;when-to-poll&quot;&gt;When to Poll&lt;/h2&gt;

&lt;p&gt;Polling is an appropriate option for observing cancellation if your code is synchronous, such as CPU-bound code. Cancellation is often thought of as only a concern for asynchronous code; it was explicitly pointed out in the documentation for &lt;code&gt;async&lt;/code&gt; when &lt;code&gt;async&lt;/code&gt; was introduced. But cancellation in .NET predates &lt;code&gt;async&lt;/code&gt;, and cancellation is just as applicable to synchronous code as to asynchronous code. In fact, &lt;code&gt;Parallel&lt;/code&gt; loops and PLINQ each have built-in support for cancellation: &lt;code&gt;ParallelOptions.CancellationToken&lt;/code&gt; for &lt;code&gt;Parallel&lt;/code&gt;, and &lt;code&gt;WithCancellation&lt;/code&gt; for PLINQ.&lt;/p&gt;

&lt;p&gt;That’s not to say you can’t use it for asynchronous code. It’s also appropriate to inject a &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; in asynchronous code, if you are not sure whether other methods will respect their cancellation tokens. Remember, taking a &lt;code&gt;CancellationToken&lt;/code&gt; parameter means that the method &lt;em&gt;may&lt;/em&gt; respect cancellation; it may also ignore the token and just ignore any cancellation requests. So your code may want to inject cancellation checks in-between “steps” of its operation. In this case, &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; isn’t so much “polling” as it is an “occasional check”:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoComplexWorkAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// From testing, it appears that DoStep1Async and DoStep2Async do not always cancel when requested.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoStep1Async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoStep2Async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you &lt;em&gt;can&lt;/em&gt; sprinkle calls to &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; throughout your code like this, I only do this when testing indicates that the code does not respect cancellation. In other words, I assume that &lt;code&gt;DoStep1Async&lt;/code&gt; and &lt;code&gt;DoStep2Async&lt;/code&gt; will respect cancellation until proven otherwise by testing.&lt;/p&gt;

&lt;p&gt;It is also appropriate to use &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; at certain points where your code is about to do something expensive. Just adding a cancellation check there means your code won’t have to do the expensive work if it’s cancelled anyway.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Polling - implemented by periodic calls to &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; - is one way to respond to cancellation requests. This is the common solution for synchronous, CPU-bound methods, and can also be used in a few other scenarios. Most asynchronous code does not use polling; we’ll cover that scenario next time!&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/03/cancellation-4-polling.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/03/cancellation-4-polling.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 3: Detecting Cancellation</title>
        <description>&lt;p&gt;It’s not uncommon to want to detect whether the cancellation actually canceled anything or not. Cancellation is cooperative, and sometimes the code requesting cancellation needs to know whether that cancellation actually took place, or whether the operation just completed normally.&lt;/p&gt;

&lt;p&gt;As a reminder, the cancellation contract has a way to communicate that: methods that take &lt;code&gt;CancellationToken&lt;/code&gt;, by convention, will throw &lt;code&gt;OperationCanceledException&lt;/code&gt; when they are cancelled. This is true for all BCL methods, and should be true for your code as well. Later in this series we’ll cover the best ways for code to respond to cancellation requests, all of which satisfy this contract, i.e., throwing &lt;code&gt;OperationCanceledException&lt;/code&gt; when they cancel.&lt;/p&gt;

&lt;h2 id=&quot;responding-to-cancellation&quot;&gt;Responding to Cancellation&lt;/h2&gt;

&lt;p&gt;The most common scenario for detecting cancellation is to avoid taking the normal error path if the code has been cancelled. Usually, the &lt;code&gt;OperationCanceledException&lt;/code&gt; is just ignored:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TryDoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Normal error handling; log, etc.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above will log any unexpected errors, but will ignore cancellation exceptions.&lt;/p&gt;

&lt;p&gt;If your code must do something &lt;em&gt;different&lt;/em&gt; when a cancellation happens, then you can handle that in a &lt;code&gt;catch&lt;/code&gt; block. Well, first, I’d recommend taking a step back and asking yourself if you &lt;em&gt;really have&lt;/em&gt; to do that, because it’s unusual and raises concerns about the code design, and it can be difficult to test as well. But if you must:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Normal error handling; log, etc.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;taskcanceledexception&quot;&gt;TaskCanceledException&lt;/h2&gt;

&lt;p&gt;You may notice that there is another cancellation exception type: &lt;code&gt;TaskCanceledException&lt;/code&gt;. This is raised by some APIs instead of &lt;code&gt;OperationCanceledException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a general rule, I recommend you completely ignore &lt;code&gt;TaskCanceledException&lt;/code&gt;. Some APIs just raise &lt;code&gt;OperationCanceledException&lt;/code&gt;, even if they deal with cancelled tasks. And since &lt;code&gt;TaskCanceledException&lt;/code&gt; derives from &lt;code&gt;OperationCanceledException&lt;/code&gt;, your cancellation exception handler code can just use &lt;code&gt;OperationCanceledException&lt;/code&gt;, ignore &lt;code&gt;TaskCanceledException&lt;/code&gt; completely, and it will work everywhere.&lt;/p&gt;

&lt;div class=&quot;alert alert-danger&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-exclamation-triangle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;Do not catch &lt;code&gt;TaskCanceledException&lt;/code&gt;. Catch &lt;code&gt;OperationCanceledException&lt;/code&gt; instead.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;operationcanceledexceptioncancellationtoken&quot;&gt;OperationCanceledException.CancellationToken&lt;/h2&gt;

&lt;p&gt;You may also notice that &lt;code&gt;OperationCanceledException&lt;/code&gt; has a &lt;code&gt;CancellationToken&lt;/code&gt; property. This is the token that caused the cancellation. That is, if it’s set; not all APIs set this value on the exceptions they throw.&lt;/p&gt;

&lt;p&gt;If your code needs to determine whether &lt;em&gt;it&lt;/em&gt; cancels the operation or whether something &lt;em&gt;else&lt;/em&gt; cancels the operation, then you might be tempted to use this property. But I recommend that your code ignore this property. When linked cancel tokens are used (a topic I’ll cover in a future post), it’s possible that the token in this property is not actually the root cause of the cancellation.&lt;/p&gt;

&lt;p&gt;More specifically:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FailFast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Bad code; do not use!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling for &amp;quot;our&amp;quot; cancellation only.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above has a problem: depending on the implementation of &lt;code&gt;DoThingAsync&lt;/code&gt;, it’s possible that &lt;code&gt;cts&lt;/code&gt; will be cancelled, and that cancellation will cause &lt;code&gt;DoThingAsync&lt;/code&gt; to throw &lt;code&gt;OperationCanceledException&lt;/code&gt;, and for the token referenced by that exception to be &lt;em&gt;different&lt;/em&gt; than the &lt;code&gt;cts&lt;/code&gt;’s token.&lt;/p&gt;

&lt;p&gt;If you do need to do special processing for when this specific cancellation happens, I recommend something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling for &amp;quot;our&amp;quot; cancellation only.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;Technically,&lt;/em&gt; the semantics of this are not “did my token cause the cancellation”, but rather “did cancellation happen and is my token requesting cancellation”. But in every case I’ve seen in the real world, the alternative semantics have been sufficient.&lt;/p&gt;

&lt;div class=&quot;alert alert-danger&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-exclamation-triangle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;Do not use &lt;code&gt;OperationCanceledException.CancellationToken&lt;/code&gt;. It doesn’t work as expected.&lt;/p&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/03/cancellation-3-detecting-cancellation.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/03/cancellation-3-detecting-cancellation.html</guid>
      </item>
    
  </channel>
</rss>
