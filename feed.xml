<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stephen Cleary (the blog)</title>
    <description>Stephen Cleary's blog: async/await, programming, language design, and other sundry computer science topics.</description>
    <link>https://blog.stephencleary.com/</link>
    <atom:link rel="self" type="application/rss+xml" href="https://blog.stephencleary.com/feed.xml" />
    <atom:link rel="search" type="application/opensearchdescription+xml" href="https://stephencleary.com/opensearch.xml" title="Cleary Search" />
    
      <item>
        <title>Modern C# Techniques, Part 2: Value Records</title>
        <description>&lt;p&gt;Today I’ll cover another technique for modern C# that isn’t exactly &lt;em&gt;new&lt;/em&gt;, but which the language supports much better than it used to.&lt;/p&gt;

&lt;p&gt;I’m calling today’s technique Value Records, which are a form of the more general “value object” pattern that is specific to modern C#. But before we dive into the solution, let’s look at the problem.&lt;/p&gt;

&lt;h2 id=&quot;primitive-obsession&quot;&gt;Primitive Obsession&lt;/h2&gt;

&lt;p&gt;The name of the antipattern we’re trying to remove is Primitive Obsession. This is a highly searchable term with some great descriptions out there.&lt;/p&gt;

&lt;p&gt;Essentially, Primitive Obsession is when a developer (over)uses primitives (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;Guid&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, etc) to represent business or domain concepts. One classic example is entity ids. There are a couple of problems with using primitives like this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The primitives are not type-safe. In other words, it’s easy to accidentally pass a &lt;code&gt;customerId&lt;/code&gt; to a method expecting a &lt;code&gt;resourceId&lt;/code&gt;. Or, say, if a method needs &lt;em&gt;both&lt;/em&gt; a &lt;code&gt;customerId&lt;/code&gt; and &lt;code&gt;resourceId&lt;/code&gt;, it’s easy to pass the parameters in the wrong order.&lt;/li&gt;
  &lt;li&gt;Primitives support operations that don’t make sense. For example, if a &lt;code&gt;customerId&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt;, the compiler will happily let you divide it by 2, but that makes no business sense at all. A related problem is when you have &lt;em&gt;units&lt;/em&gt;, such as &lt;code&gt;distanceInFeet&lt;/code&gt; and &lt;code&gt;distanceInMeters&lt;/code&gt;; the lack of units in the type system allow these values to be (incorrectly) added together.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;solving-primitive-obsesesion-with-value-objects&quot;&gt;Solving Primitive Obsesesion with Value Objects&lt;/h2&gt;

&lt;p&gt;Value Objects are the general solution to Primitive Obsession. The idea is that you define a (simple) domain object that wraps the primitive type inside a type-safe wrapper type. In some cases, this wrapper type may have some limited domain behavior (such as validation), but in many cases Value Objects are so-called “anemic domain models”, and that’s OK. Value Objects inhabit a middle ground between primitives and full-blown domain objects.&lt;/p&gt;

&lt;p&gt;Value Objects tend to behave similarly to the primitives they replace:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Value Objects are usually immutable.&lt;/li&gt;
  &lt;li&gt;Value Objects usually have value semantics.&lt;/li&gt;
  &lt;li&gt;If a primitive has a useful operation (e.g., string concatenation, integer addition, or even &lt;code&gt;ToString&lt;/code&gt; or &lt;code&gt;GetHashCode&lt;/code&gt; support) that also makes sense for the domain object, then Value Objects usually support those operations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Following these patterns allows Value Objects to essentially be type-safe replacements for primitives. Occasionally some business rules are added (e.g., validation), but just plain old Value Objects work quite well on their own, too.&lt;/p&gt;

&lt;h2 id=&quot;c-and-value-records&quot;&gt;C# and Value Records&lt;/h2&gt;

&lt;p&gt;The modern C# technique for Value Objects is what I call Value Records, and looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;public readonly struct record CustomerId(string Value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, that’s the whole type.&lt;/p&gt;

&lt;p&gt;Breaking it down:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Records provide value semantics, complete with equality, hash code, and &lt;code&gt;ToString&lt;/code&gt; support.&lt;/li&gt;
  &lt;li&gt;Struct records provide a value-type wrapper, avoiding heap allocation (the size of the wrapper &lt;em&gt;is&lt;/em&gt; the size of the wrapped value).&lt;/li&gt;
  &lt;li&gt;Readonly struct records provide immutability.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I prefer to use a single property named &lt;code&gt;Value&lt;/code&gt;, which is similar to &lt;code&gt;Nullable&amp;lt;T&amp;gt;.Value&lt;/code&gt;, except a Value Record &lt;em&gt;always&lt;/em&gt; has a valid &lt;code&gt;Value&lt;/code&gt;. Since the type definition is just a single line, it seems silly to have them follow the one-type-per-file rule; I tend to collect Value Record types and include them in a single source file, usually called &lt;code&gt;Primitives.cs&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;guidelines-for-use&quot;&gt;Guidelines for Use&lt;/h2&gt;

&lt;h3 id=&quot;avoid-sharp-edges&quot;&gt;Avoid Sharp Edges&lt;/h3&gt;

&lt;p&gt;I’ve used Value Records in a few projects now, and I think they work best as internal types. I don’t mean &lt;code&gt;internal&lt;/code&gt;; I mean as types that are created and unwrapped by your own code at the “edges” of your app. Then the core of your app &lt;em&gt;only&lt;/em&gt; deals with the Value Records.&lt;/p&gt;

&lt;p&gt;This way you don’t have to deal with any kind of serialization, which can be a real headache. I recommend you completely ignore Newtonsoft.Json / System.Text.Json / Xml, ASP.NET parameter binding / output formatting, WPF bindings, Entity Framework value conversions, and all other forms of serialization. Instead of trying to automatically support these, just have your own code create the Value Record wrappers when reading the values from an external source (e.g., &lt;code&gt;CustomerId customerId = new(customerIdIntValue)&lt;/code&gt;), and unwrap them when writing values to an external source (e.g., &lt;code&gt;int customerIdIntValue = customerId.Value;&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;choosing-primitives-to-replace&quot;&gt;Choosing Primitives to Replace&lt;/h3&gt;

&lt;p&gt;Not all primitives &lt;em&gt;need&lt;/em&gt; to be Value Records. Choosing which primitives &lt;em&gt;should&lt;/em&gt; be Value Records is a skill, one which everyone is developing right now, and there are no masters of this skill yet AFAIK.&lt;/p&gt;

&lt;p&gt;In my experience, I would say to use primitives by default, but use Value Records in the following situations:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Use Value Records whenever you have similar value types that are used together.
    &lt;ul&gt;
      &lt;li&gt;“Similar” here can mean &lt;em&gt;conceptually&lt;/em&gt; similar or just having a similar &lt;em&gt;name&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Use Value Records whenever you have to &lt;em&gt;guarantee&lt;/em&gt; that a critical value type &lt;em&gt;must&lt;/em&gt; be used only in a particular way.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The classic example of the first situation (similar types) is using Value Records for entity identifiers (&lt;code&gt;CustomerId&lt;/code&gt; and friends). Entity identifiers are conceptually similar &lt;em&gt;and&lt;/em&gt; have similar names, and usually there are multiple methods that deal with different kinds of identifiers at the same time.&lt;/p&gt;

&lt;p&gt;The second situation (critical types) is more of a judgement call. I can at least give an example, though: one of my projects sends emails to users, but also has to deal with users that type in an email address that may or may not be theirs. And there are some severe repercussions for sending emails to people who haven’t asked for them; there’s actual laws in my country about that kind of behavior. So, I created a &lt;code&gt;ValidatedEmail&lt;/code&gt; Value Record for this critical type. In my model, a user has a &lt;code&gt;ValidatedEmail&lt;/code&gt; (whose value may be &lt;code&gt;null&lt;/code&gt;), and the code component that sends emails &lt;em&gt;only&lt;/em&gt; accepts a &lt;code&gt;ValidatedEmail&lt;/code&gt;. It’s comforting to know that the type system itself is enforcing the business rule “only send emails to validated email addresses”.&lt;/p&gt;

&lt;h2 id=&quot;misuse&quot;&gt;Misuse&lt;/h2&gt;

&lt;p&gt;Similar to last week’s technique, the primary misuse of the Value Record technique is &lt;em&gt;overuse&lt;/em&gt;. Once you start feeling the benefits of the stronger type safety from Value Records, you’ll start wanting it everywhere. You may end up temporarily suffering from “Primitive Obsession Obsession”, if you will.&lt;/p&gt;

&lt;p&gt;There’s a maintenance tradeoff with using Value Records: Value Records increase the code complexity. Speficially, Value Records increase the mental burden when reading the code. Put simply: every developer knows what a &lt;code&gt;string&lt;/code&gt; is, but if they see a &lt;code&gt;CustomerId&lt;/code&gt; type, then they need to look that up. Remember, techniques like Value Records are easy to write because they’re in &lt;em&gt;your&lt;/em&gt; head &lt;em&gt;now&lt;/em&gt;, but the resulting code is more difficult to maintain (whether maintained by &lt;em&gt;others&lt;/em&gt; or yourself &lt;em&gt;later&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;After all, it’s not like primitives are evil or anything like that. Primitives are a perfectly fine solution for a lot of data. &lt;code&gt;string CustomerName&lt;/code&gt; is probably just fine; it wouldn’t have any real validation and is unlikely to be confused with something else. Well, that’s true unless your domain has a ton of “names”, in which case maybe it &lt;em&gt;can&lt;/em&gt; be easily confused with another kind of name and &lt;em&gt;should&lt;/em&gt; be a Value Record.&lt;/p&gt;

&lt;h2 id=&quot;history&quot;&gt;History&lt;/h2&gt;

&lt;p&gt;Until records were added to the language, immutable objects were always a bit of a pain, with some going so far as to &lt;a href=&quot;https://github.com/AArnott/ImmutableObjectGraph&quot;&gt;create libraries just to help write immutable types&lt;/a&gt;. The Value Object pattern was used only when absolutely necessary, since it resulted in much more complex code (with a naturally higher probability of containing bugs).&lt;/p&gt;

&lt;p&gt;If you haven’t read it yet, &lt;a href=&quot;https://andrewlock.net/series/using-strongly-typed-entity-ids-to-avoid-primitive-obsession/&quot;&gt;Andrew Lock has a great blog series on using strongly-typed entity IDs to avoid primitive obsession&lt;/a&gt;. I think overall it’s a good series conceptually, but do note that the implementation details are quite dated at this point. Also note how much the complexity is increased by trying to handle only a couple forms of serialization.&lt;/p&gt;

&lt;p&gt;Record types brought immutability to C# as a first-class citizen. The initial record types were class records (reference types), which works great for many immutable types, but tends to be a heavyweight solution for Value Objects. E.g., when wrapping &lt;code&gt;int&lt;/code&gt; values, a &lt;code&gt;class record&lt;/code&gt; wrapper essentially acts as an always-boxed &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These days we have readonly struct records, which are immutable &lt;em&gt;and&lt;/em&gt; lightweight, and a perfect fit for the Value Object pattern.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Carefully replacing some primitive types with Value Records will increase the type safety, correctness, and maintainability of your code.&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Oct 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/10/modern-csharp-techniques-2-value-records.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/10/modern-csharp-techniques-2-value-records.html</guid>
      </item>
    
      <item>
        <title>Modern C# Techniques, Part 1: Curiously Recurring Generic Pattern</title>
        <description>&lt;p&gt;I’m starting a new series today looking at some modern C# techniques. Part of what I like about C# is that the language is always improving, and those improvements bring newer code patterns with them.&lt;/p&gt;

&lt;p&gt;Today’s topic is not actually &lt;em&gt;new&lt;/em&gt;, but many developers haven’t seen it before, so it’s worth taking a look at. As with many of the techniques I’ll be discussing, I’m not sure if this one has a name, so I am just calling it whatever I call it in my head.&lt;/p&gt;

&lt;h2 id=&quot;the-curiously-recurring-generic-pattern&quot;&gt;The Curiously Recurring Generic Pattern&lt;/h2&gt;

&lt;div class=&quot;alert alert-info&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;The “curious” name for this pattern comes from the C++ world, where it was called the Curiously Recurring Template Pattern. So in C# I just call it the Curiously Recurring Generic Pattern, since it’s essentially the same thing but with generics instead of templates. &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot; class=&quot;alert-link&quot;&gt;According to Wikipedia&lt;/a&gt;, it’s actually “F-bound polymorphism”, but I’m not going to remember that.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;The Curiously Recurring Generic Pattern is when an interface (or base type) takes a generic parameter that is its own derived type. A simple example looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;interface IExample&amp;lt;TDerived&amp;gt;
{
}

class MyExample : IExample&amp;lt;MyExample&amp;gt;
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;but-why-tho&quot;&gt;But Why Tho?&lt;/h2&gt;

&lt;p&gt;It essentially comes down to typing. If an interface (or base type) wants to use the &lt;em&gt;full, derived type&lt;/em&gt; as a method parameter or return value, then it can define those methods itself without putting any burdern on the derived type.&lt;/p&gt;

&lt;p&gt;Consider a familiar example from the .NET BCL: &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1?view=net-6.0&amp;amp;WT.mc_id=DT-MVP-5000058&quot;&gt;is defined&lt;/a&gt; as thus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;public interface IEquatable&amp;lt;T&amp;gt;
{
  bool Equals(T? other);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is used as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;sealed class MyEquatable : IEquatable&amp;lt;MyEquatable&amp;gt;
{
  public bool Equals(MyEquatable? other) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The thing to note here is that &lt;code&gt;MyEquatable.Equals&lt;/code&gt; implements &lt;code&gt;IEquatable&amp;lt;T&amp;gt;.Equals&lt;/code&gt; with a &lt;em&gt;strongly-typed&lt;/em&gt; &lt;code&gt;MyEquatable&lt;/code&gt; argument. If the Curiously Recurring Generic Pattern wasn’t used, then &lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt; would just be &lt;code&gt;IEquatable&lt;/code&gt; (taking an &lt;code&gt;object&lt;/code&gt; argument), losing type safety and efficiency.&lt;/p&gt;

&lt;h2 id=&quot;adding-a-generic-constraint&quot;&gt;Adding a Generic Constraint&lt;/h2&gt;

&lt;p&gt;The interface (or base type) may also use itself as a generic constraint. It doesn’t &lt;em&gt;have&lt;/em&gt; to (the examples above don’t), but sometimes it’s useful, particularly for base types. The Curiously Recurring Generic Pattern with generic constraints looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C#&quot;&gt;abstract class ExampleBase&amp;lt;TDerived&amp;gt;
    where TDerived : ExampleBase&amp;lt;TDerived&amp;gt;
{
  // Methods in here can use `(TDerived)this` freely.
  // This is particularly useful if this interface wants to *return* a value of TDerived.
  public virtual TDerived Something() =&amp;gt; (TDerived)this;
}

class AnotherExample : ExampleBase&amp;lt;AnotherExample&amp;gt;
{
  // Implicitly has `public AnotherExample Something();` defined.
  // The base class method already has the correct return type.
  // (Can still override if desired).
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As noted in the comments above, this approach is useful if &lt;code&gt;TDerived&lt;/code&gt; is used as a &lt;em&gt;return&lt;/em&gt; type. As one example, this is common with fluent APIs.&lt;/p&gt;

&lt;p&gt;More generally, the generic constraint is needed in either of these situations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The base type needs to treat a &lt;code&gt;ExampleBase&amp;lt;TDerived&amp;gt;&lt;/code&gt; instance (e.g., &lt;code&gt;this&lt;/code&gt;) as its derived type (i.e., &lt;code&gt;(TDerived)this&lt;/code&gt;). This can also come up when passing &lt;code&gt;this&lt;/code&gt; to other methods.&lt;/li&gt;
  &lt;li&gt;The base type needs to treat a &lt;code&gt;TDerived&lt;/code&gt; as a &lt;code&gt;ExampleBase&amp;lt;TDerived&amp;gt;&lt;/code&gt;, e.g., calling private base methods on an instance of type &lt;code&gt;TDerived&lt;/code&gt; &lt;em&gt;other&lt;/em&gt; than &lt;code&gt;this&lt;/code&gt;. In this case no explicit cast is necessary.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;crgp-and-default-interface-methods&quot;&gt;CRGP and Default Interface Methods&lt;/h2&gt;

&lt;p&gt;Similar to regular interface methods, the Curiously Recurring Generic Pattern can enhance the type safety of &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods?WT.mc_id=DT-MVP-5000058&quot;&gt;default interface methods&lt;/a&gt; if necessary. This is similar to using CRGP with base types, except interfaces cannot have state. Put another way, this enables strongly-typed traits, but falls short of mixins.&lt;/p&gt;

&lt;h2 id=&quot;crgp-and-static-interface-methods-and-operators&quot;&gt;CRGP and Static Interface Methods (and Operators)&lt;/h2&gt;

&lt;p&gt;One possibility for CRGP with &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members?WT.mc_id=DT-MVP-5000058&quot;&gt;static interface methods&lt;/a&gt; is to define operators (or other static methods) with the proper type signatures. Previously, CRGP required a base type to define operators (e.g., &lt;a href=&quot;https://github.com/StephenCleary/Comparers/blob/48cd202db5d7ea7209cc4248bf6a531d3752f170/src/Nito.Comparers.Core/EquatableBaseWithOperators.cs&quot;&gt;&lt;code&gt;EquatableBaseWithOperators&amp;lt;TDerived&amp;gt;&lt;/code&gt; in my Nito.Comparers library&lt;/a&gt;), but using CRGP with static interface methods allows strong typing for operator signatures (e.g., &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.numerics.iunarynegationoperators-2?view=net-7.0&amp;amp;WT.mc_id=DT-MVP-5000058&quot;&gt;&lt;code&gt;IUnaryNegationOperators&amp;lt;TSelf, TResult&amp;gt;&lt;/code&gt;&lt;/a&gt; is an interface that defines &lt;code&gt;operator-&lt;/code&gt; with the proper type signature).&lt;/p&gt;

&lt;h2 id=&quot;misuse&quot;&gt;Misuse&lt;/h2&gt;

&lt;p&gt;Like other code patterns, the CRGP can be misused. IMO the most common misuse of this pattern is &lt;em&gt;overuse&lt;/em&gt;. Bear in mind CRGP isn’t powerful enough to provide mixins - even with default interface methods (which provide traits, not mixins).&lt;/p&gt;

&lt;p&gt;Also, CRGP tends to make the code more complex. There’s a tradeoff there, and you need to keep maintainability in mind.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;The Curiously Recurring Generic Pattern isn’t actually new, and it isn’t often necessary, but it’s a nice tool to have when you do need it.&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/09/modern-csharp-techniques-1-curiously-recurring-generic-pattern.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 4: Polling</title>
        <description>&lt;p&gt;So far in this series, I’ve talked about how to request and detect cancellation, but for the next couple of posts I’ll be switching perspectives and discussing ways to respond to cancellation.&lt;/p&gt;

&lt;p&gt;I know I’ve probably said this a half dozen times already, but it bears repeating: cancellation is cooperative. Your code will be provided a &lt;code&gt;CancellationToken&lt;/code&gt;, and it must &lt;em&gt;do&lt;/em&gt; something with that &lt;code&gt;CancellationToken&lt;/code&gt; in order to be cancelable. Most of the time, this is just passing the &lt;code&gt;CancellationToken&lt;/code&gt; down to lower-level APIs, but if you want cancelable code at the lowest level, there are a couple of other options. The one we’re looking at today is polling.&lt;/p&gt;

&lt;h2 id=&quot;how-to-poll&quot;&gt;How to Poll&lt;/h2&gt;

&lt;p&gt;The normal pattern is to periodically call &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do synchronous work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The example code above checks the cancellation token &lt;em&gt;before&lt;/em&gt; it starts work, which is a good general practice. It is possible that the token is already cancelled by the time your operation starts running.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; will check to see if cancellation is requested, and if it is, it will throw &lt;code&gt;OperationCanceledException&lt;/code&gt;. So it handles the proper reporting of cancellation for you; your code should just let that exception propagate out of the method.&lt;/p&gt;

&lt;p&gt;One question you’ll need to answer is how &lt;em&gt;often&lt;/em&gt; to poll. There really isn’t a good answer for this; ideally you probably want to poll a few times a second, but when you’re talking about CPU-bound code running on potentially very different machines, it’s pretty much a guess at where in the code the &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; should go. Just put it in the best place(s), run some tests to see if cancellation feels responsive enough, and that’s the best you can do.&lt;/p&gt;

&lt;h2 id=&quot;how-not-to-poll&quot;&gt;How Not to Poll&lt;/h2&gt;

&lt;p&gt;There’s a sadly common antipattern regarding polling for cancellation, particularly in infinite loops: the “while not cancelled” loop, which looks like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingForever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FailFast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Bad code! Do not use!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When this code runs, it will periodically check the cancellation token; but when cancellation is requested, the method just returns early. This method doesn’t satisfy the cancellation contract of throwing an exception on cancellation. This means that the calling code cannot know whether the method ran to completion or whether it was cancelled.&lt;/p&gt;

&lt;p&gt;The proper solution is to use &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt;, even for infinite loops:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingForever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// do work&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;when-to-poll&quot;&gt;When to Poll&lt;/h2&gt;

&lt;p&gt;Polling is an appropriate option for observing cancellation if your code is synchronous, such as CPU-bound code. Cancellation is often thought of as only a concern for asynchronous code; it was explicitly pointed out in the documentation for &lt;code&gt;async&lt;/code&gt; when &lt;code&gt;async&lt;/code&gt; was introduced. But cancellation in .NET predates &lt;code&gt;async&lt;/code&gt;, and cancellation is just as applicable to synchronous code as to asynchronous code. In fact, &lt;code&gt;Parallel&lt;/code&gt; loops and PLINQ each have built-in support for cancellation: &lt;code&gt;ParallelOptions.CancellationToken&lt;/code&gt; for &lt;code&gt;Parallel&lt;/code&gt;, and &lt;code&gt;WithCancellation&lt;/code&gt; for PLINQ.&lt;/p&gt;

&lt;p&gt;That’s not to say you can’t use it for asynchronous code. It’s also appropriate to inject a &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; in asynchronous code, if you are not sure whether other methods will respect their cancellation tokens. Remember, taking a &lt;code&gt;CancellationToken&lt;/code&gt; parameter means that the method &lt;em&gt;may&lt;/em&gt; respect cancellation; it may also ignore the token and just ignore any cancellation requests. So your code may want to inject cancellation checks in-between “steps” of its operation. In this case, &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; isn’t so much “polling” as it is an “occasional check”:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoComplexWorkAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// From testing, it appears that DoStep1Async and DoStep2Async do not always cancel when requested.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoStep1Async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThrowIfCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoStep2Async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you &lt;em&gt;can&lt;/em&gt; sprinkle calls to &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; throughout your code like this, I only do this when testing indicates that the code does not respect cancellation. In other words, I assume that &lt;code&gt;DoStep1Async&lt;/code&gt; and &lt;code&gt;DoStep2Async&lt;/code&gt; will respect cancellation until proven otherwise by testing.&lt;/p&gt;

&lt;p&gt;It is also appropriate to use &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; at certain points where your code is about to do something expensive. Just adding a cancellation check there means your code won’t have to do the expensive work if it’s cancelled anyway.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Polling - implemented by periodic calls to &lt;code&gt;ThrowIfCancellationRequested&lt;/code&gt; - is one way to respond to cancellation requests. This is the common solution for synchronous, CPU-bound methods, and can also be used in a few other scenarios. Most asynchronous code does not use polling; we’ll cover that scenario next time!&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/03/cancellation-4-polling.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/03/cancellation-4-polling.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 3: Detecting Cancellation</title>
        <description>&lt;p&gt;It’s not uncommon to want to detect whether the cancellation actually canceled anything or not. Cancellation is cooperative, and sometimes the code requesting cancellation needs to know whether that cancellation actually took place, or whether the operation just completed normally.&lt;/p&gt;

&lt;p&gt;As a reminder, the cancellation contract has a way to communicate that: methods that take &lt;code&gt;CancellationToken&lt;/code&gt;, by convention, will throw &lt;code&gt;OperationCanceledException&lt;/code&gt; when they are cancelled. This is true for all BCL methods, and should be true for your code as well. Later in this series we’ll cover the best ways for code to respond to cancellation requests, all of which satisfy this contract, i.e., throwing &lt;code&gt;OperationCanceledException&lt;/code&gt; when they cancel.&lt;/p&gt;

&lt;h2 id=&quot;responding-to-cancellation&quot;&gt;Responding to Cancellation&lt;/h2&gt;

&lt;p&gt;The most common scenario for detecting cancellation is to avoid taking the normal error path if the code has been cancelled. Usually, the &lt;code&gt;OperationCanceledException&lt;/code&gt; is just ignored:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TryDoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Normal error handling; log, etc.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above will log any unexpected errors, but will ignore cancellation exceptions.&lt;/p&gt;

&lt;p&gt;If your code must do something &lt;em&gt;different&lt;/em&gt; when a cancellation happens, then you can handle that in a &lt;code&gt;catch&lt;/code&gt; block. Well, first, I’d recommend taking a step back and asking yourself if you &lt;em&gt;really have&lt;/em&gt; to do that, because it’s unusual and raises concerns about the code design, and it can be difficult to test as well. But if you must:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Normal error handling; log, etc.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;taskcanceledexception&quot;&gt;TaskCanceledException&lt;/h2&gt;

&lt;p&gt;You may notice that there is another cancellation exception type: &lt;code&gt;TaskCanceledException&lt;/code&gt;. This is raised by some APIs instead of &lt;code&gt;OperationCanceledException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a general rule, I recommend you completely ignore &lt;code&gt;TaskCanceledException&lt;/code&gt;. Some APIs just raise &lt;code&gt;OperationCanceledException&lt;/code&gt;, even if they deal with cancelled tasks. And since &lt;code&gt;TaskCanceledException&lt;/code&gt; derives from &lt;code&gt;OperationCanceledException&lt;/code&gt;, your cancellation exception handler code can just use &lt;code&gt;OperationCanceledException&lt;/code&gt;, ignore &lt;code&gt;TaskCanceledException&lt;/code&gt; completely, and it will work everywhere.&lt;/p&gt;

&lt;div class=&quot;alert alert-danger&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-exclamation-triangle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;Do not catch &lt;code&gt;TaskCanceledException&lt;/code&gt;. Catch &lt;code&gt;OperationCanceledException&lt;/code&gt; instead.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;operationcanceledexceptioncancellationtoken&quot;&gt;OperationCanceledException.CancellationToken&lt;/h2&gt;

&lt;p&gt;You may also notice that &lt;code&gt;OperationCanceledException&lt;/code&gt; has a &lt;code&gt;CancellationToken&lt;/code&gt; property. This is the token that caused the cancellation. That is, if it’s set; not all APIs set this value on the exceptions they throw.&lt;/p&gt;

&lt;p&gt;If your code needs to determine whether &lt;em&gt;it&lt;/em&gt; cancels the operation or whether something &lt;em&gt;else&lt;/em&gt; cancels the operation, then you might be tempted to use this property. But I recommend that your code ignore this property. When linked cancel tokens are used (a topic I’ll cover in a future post), it’s possible that the token in this property is not actually the root cause of the cancellation.&lt;/p&gt;

&lt;p&gt;More specifically:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FailFast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Bad code; do not use!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling for &amp;quot;our&amp;quot; cancellation only.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above has a problem: depending on the implementation of &lt;code&gt;DoThingAsync&lt;/code&gt;, it’s possible that &lt;code&gt;cts&lt;/code&gt; will be cancelled, and that cancellation will cause &lt;code&gt;DoThingAsync&lt;/code&gt; to throw &lt;code&gt;OperationCanceledException&lt;/code&gt;, and for the token referenced by that exception to be &lt;em&gt;different&lt;/em&gt; than the &lt;code&gt;cts&lt;/code&gt;’s token.&lt;/p&gt;

&lt;p&gt;If you do need to do special processing for when this specific cancellation happens, I recommend something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wire up something that may cancel the CTS.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoThingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperationCanceledException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsCancellationRequested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Special cancellation handling for &amp;quot;our&amp;quot; cancellation only.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;Technically,&lt;/em&gt; the semantics of this are not “did my token cause the cancellation”, but rather “did cancellation happen and is my token requesting cancellation”. But in every case I’ve seen in the real world, the alternative semantics have been sufficient.&lt;/p&gt;

&lt;div class=&quot;alert alert-danger&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-exclamation-triangle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;Do not use &lt;code&gt;OperationCanceledException.CancellationToken&lt;/code&gt;. It doesn’t work as expected.&lt;/p&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/03/cancellation-3-detecting-cancellation.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/03/cancellation-3-detecting-cancellation.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 2: Requesting Cancellation</title>
        <description>&lt;p&gt;&lt;a href=&quot;/2022/02/cancellation-1-overview.html&quot;&gt;Last time&lt;/a&gt; we covered the basic cancellation contract. Responding code takes a &lt;code&gt;CancellationToken&lt;/code&gt;, which is a way to communicate a cancellation request. Today we’re looking at how to create &lt;code&gt;CancellationToken&lt;/code&gt;s and how to request cancellation.&lt;/p&gt;

&lt;h2 id=&quot;cancellationtokensource&quot;&gt;CancellationTokenSource&lt;/h2&gt;

&lt;p&gt;Some &lt;code&gt;CancellationToken&lt;/code&gt;s are provided by a framework or library that you’re using. For example, ASP.NET will provide you a &lt;code&gt;CancellationToken&lt;/code&gt; that represents an unexpected client disconnect. As another example, Polly can provide your delegate with a &lt;code&gt;CancellationToken&lt;/code&gt; that represents a more generic cancellation (e.g., a timeout policy being triggered).&lt;/p&gt;

&lt;p&gt;For other scenarios, you’ll need to provide your own &lt;code&gt;CancellationToken&lt;/code&gt;. You can use the &lt;code&gt;CancellationToken&lt;/code&gt; constructor or &lt;code&gt;CancellationToken.None&lt;/code&gt; to create a cancellation token that is either signalled (and always signalled) or unsignalled (and never signalled).&lt;/p&gt;

&lt;p&gt;But in the general case, when you want to create a &lt;code&gt;CancellationToken&lt;/code&gt; that can be cancelled later, then you’ll need to use &lt;code&gt;CancellationTokenSource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;CancellationTokenSource&lt;/code&gt; controls its own set of &lt;code&gt;CancellationToken&lt;/code&gt;s. Each &lt;code&gt;CancellationToken&lt;/code&gt; created from a &lt;code&gt;CancellationTokenSource&lt;/code&gt; is just a small &lt;code&gt;struct&lt;/code&gt; that refers back to its &lt;code&gt;CancellationTokenSource&lt;/code&gt;. A &lt;code&gt;CancellationToken&lt;/code&gt; can only respond to cancellation requests; the &lt;code&gt;CancellationTokenSource&lt;/code&gt; is necessary to request cancellation. So the requesting code creates the &lt;code&gt;CancellationTokenSource&lt;/code&gt; and keeps a reference to it (using that reference later to request cancellation), and the responding code just gets a &lt;code&gt;CancellationToken&lt;/code&gt; and uses that to respond to the cancellation requests.&lt;/p&gt;

&lt;h2 id=&quot;timeouts&quot;&gt;Timeouts&lt;/h2&gt;

&lt;p&gt;One common need for cancellation is implementing a timeout. The solution is to have a timer that requests cancellation when it expires. This is actually common enough that &lt;code&gt;CancellationTokenSource&lt;/code&gt; has this behavior built-in. You can either use the &lt;code&gt;CancellationTokenSource&lt;/code&gt; constructor that takes a delay, or call &lt;code&gt;CancelAfter&lt;/code&gt; on an existing &lt;code&gt;CancellationTokenSource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, if you want to apply a timeout to a code scope:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingWithTimeoutAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Create a CTS that cancels after 5 minutes.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;CancellationTokenSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeSpan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FromMinutes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Pass the token for that CTS to lower-level code.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// At the end of this method, the CTS is disposed.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// All of its tokens should not be used after this point.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;manual-cancellation&quot;&gt;Manual Cancellation&lt;/h2&gt;

&lt;p&gt;For more general cancellation needs, create a &lt;code&gt;CancellationTokenSource&lt;/code&gt;, and at some point in the future call its &lt;code&gt;Cancel&lt;/code&gt; method to manually request cancellation.&lt;/p&gt;

&lt;p&gt;One example is a GUI application with an actual “Cancel” button:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationTokenSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Create a CTS for manual cancellation requests.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Pass the token for that CTS to lower-level code.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display error in UI.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CancelButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Manually cancel the CTS.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above shows the basic idea, but has some serious problems that you wouldn’t want to have in production. For one thing, the cancel button can be clicked when &lt;code&gt;_cts&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, causing a &lt;code&gt;NullReferenceException&lt;/code&gt;. Also, the start button handler will blindly overwrite any &lt;code&gt;_cts&lt;/code&gt; value, ignoring any existing ongoing operation.&lt;/p&gt;

&lt;p&gt;The proper resolution of these issues depends on your desired user experience and nature of the operation. Just to make this example more complete and production-ready, let’s implement the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Either the start or cancel buttons should be enabled at any time, never both.&lt;/li&gt;
  &lt;li&gt;If the operation completes on its own, the start button should be enabled and the cancel button disabled.&lt;/li&gt;
  &lt;li&gt;If the operation is cancelled, the start button should remain disabled until the operation completes (either successfully or with an &lt;code&gt;OperationCanceledException&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;After the operation is cancelled, the cancel button remains enabled but becomes a noop.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These requirements result in this kind of code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationTokenSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Create a CTS for manual cancellation requests.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Pass the token for that CTS to lower-level code.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display success in UI.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display error in UI.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CancelButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Manually cancel the CTS.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may wish to have different requirements. For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Either the start or cancel buttons should be enabled at any time, never both.&lt;/li&gt;
  &lt;li&gt;If the operation completes on its own, the start button should be enabled and the cancel button disabled.&lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;If the operation is cancelled, the start button should remain disabled until the operation completes (either successfully or with an `OperationCanceledException`).&lt;/s&gt;
    &lt;p&gt;&lt;em&gt;If one operation is cancelled, the start button should become enabled immediately. Any cancelled operations no longer cause any UI updates.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;After the operation is cancelled, the cancel button remains enabled but becomes a noop.&lt;/s&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since the new requirements allow the user to start a new operation &lt;em&gt;as soon as the old operation is cancelled&lt;/em&gt; (without waiting for the old operation to complete), the “update the UI” code needs to be guarded to ensure only the current operation updates the UI:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationTokenSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StartButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Create a CTS for manual cancellation requests.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// In this method, we can check whether we are the current operation by doing (cts == _cts)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This works because _cts changes every time the start button is clicked.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Pass the token for that CTS to lower-level code.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display success in UI.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Display error in UI.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CancelButton_Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(..)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StartButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CancelButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Enabled&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Manually cancel the CTS.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Ensure cancelled operations do not update the UI with success/errors&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_cts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There are many other options available, depending on your desired user experience. For example, you might choose to keep the start button enabled and just have it implicitly cancel the previous operation (if any). Whatever you end up with, just be sure to walk through all the possible states of your UI and ensure that your handlers are interacting with your &lt;code&gt;CancellationTokenSource&lt;/code&gt; instances appropriately.&lt;/p&gt;

&lt;h2 id=&quot;cleaning-up-cancelling-and-disposing&quot;&gt;Cleaning Up: Cancelling and Disposing&lt;/h2&gt;

&lt;p&gt;To avoid resource leaks, it’s important to clean up your &lt;code&gt;CancellationTokenSource&lt;/code&gt; instances. There are a couple of kinds of resources that are cleaned up: first, the timeout timer (if any) is freed; second, any “listeners” attached to &lt;code&gt;CancellationToken&lt;/code&gt;s are freed (we’ll cover “listening” registrations later in this series). This cleanup is done when the &lt;code&gt;CancellationTokenSource&lt;/code&gt; is cancelled &lt;em&gt;or&lt;/em&gt; when it’s disposed. You can either cancel or dispose, but you should ensure one or the other is done to avoid resource leaks.&lt;/p&gt;

&lt;p&gt;The examples in this blog post always dispose the &lt;code&gt;CancelltionTokenSource&lt;/code&gt; when the responding code is done executing (and thus the &lt;code&gt;CancellationToken&lt;/code&gt;s are no longer used). If the &lt;code&gt;CancellationToken&lt;/code&gt; is saved and used later, then you &lt;em&gt;don’t&lt;/em&gt; want to dispose the &lt;code&gt;CancellationTokenSource&lt;/code&gt;. In that case, you’d want to keep the &lt;code&gt;CancellationTokenSource&lt;/code&gt; alive until you are sure that all code is done with its &lt;code&gt;CancellationToken&lt;/code&gt;s. This is a more advanced case, and sometimes it’s more convenient to cancel the &lt;code&gt;CancellationTokenSource&lt;/code&gt; rather than disposing it.&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/03/cancellation-2-requesting-cancellation.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/03/cancellation-2-requesting-cancellation.html</guid>
      </item>
    
      <item>
        <title>Cancellation, Part 1: Overview</title>
        <description>&lt;p&gt;Cancellation is a topic that I haven’t written on much yet, because the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads?WT.mc_id=DT-MVP-5000058&quot;&gt;Microsoft documentation&lt;/a&gt; is quite good. But after answering many questions for many years, I thought it would be a good topic to cover once, exhaustively.&lt;/p&gt;

&lt;h2 id=&quot;cooperative-cancellation&quot;&gt;Cooperative Cancellation&lt;/h2&gt;

&lt;p&gt;Cancellation in .NET is &lt;em&gt;cooperative&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What this really means is that one part of the code Requests cancellation, and another part of the code Responds to that request. We often talk about some code “cancelling” other code, but what actually happens is that the requesting code just politely notifies the other code that it would like it to please stop, and the responding code may react to that cancellation request in any way it chooses. The responding code may immediately stop what it is doing, or it may continue until it reaches a valid stopping point, or it may ignore the cancellation request completely.&lt;/p&gt;

&lt;p&gt;So, the important takeaway here is that the responding code must respond to the cancellation request in order for cancellation to actually &lt;em&gt;cancel&lt;/em&gt; anything.&lt;/p&gt;

&lt;p&gt;This discussion usually brings up a question: What about code that doesn’t cooperate? I.e., how do I cancel uncancelable code? This is actually an advanced scenario, so I’ll discuss it (with solutions) at the end of this series.&lt;/p&gt;

&lt;h2 id=&quot;cancellation-tokens-and-the-90-case&quot;&gt;Cancellation Tokens and the 90% Case&lt;/h2&gt;

&lt;p&gt;In .NET, a cancellation token is the “carrier” of a cancellation request. The requesting code will cancel a cancellation token, and the responding code reacts to the token being cancelled. We’ll look at the details of how to create and cancel tokens - as well as how to respond to them - in future posts. For now, it’s sufficient to know that the cancellation token is how the cancellation request is passed from the requesting code to the responding code.&lt;/p&gt;

&lt;p&gt;In fact, I’d say about 90% of the cancellation code you’ll need to write is simply that: add a &lt;code&gt;CancellationToken&lt;/code&gt; parameter to your method and then pass it down to whatever APIs you call:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intermediateValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoFirstStepAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSecondStepAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intermediateValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A &lt;code&gt;CancellationToken&lt;/code&gt; can be any kind of cancellation: a user pressing a Cancel button; a client disconnecting from a server; an application shutting down; a timeout. It shouldn’t matter to your code &lt;em&gt;why&lt;/em&gt; it’s being cancelled; just the fact that it &lt;em&gt;is&lt;/em&gt; being cancelled.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;CancellationToken&lt;/code&gt; may only be cancelled one time; once it is cancelled, it is always cancelled.&lt;/p&gt;

&lt;h2 id=&quot;the-cancellation-contract-method-signature&quot;&gt;The Cancellation Contract: Method Signature&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap#cancellation-optional?WT.mc_id=DT-MVP-5000058&quot;&gt;By convention&lt;/a&gt;, the &lt;code&gt;CancellationToken&lt;/code&gt; parameter is usually the last parameter unless an &lt;code&gt;IProgress&amp;lt;T&amp;gt;&lt;/code&gt; parameter is present. It is common to provide an overload or default parameter so that callers do not &lt;em&gt;have&lt;/em&gt; to provide a &lt;code&gt;CancellationToken&lt;/code&gt; if they do not have one; the &lt;code&gt;default&lt;/code&gt; value of a &lt;code&gt;CancellationToken&lt;/code&gt; is the same as &lt;code&gt;CancellationToken.None&lt;/code&gt;, i.e., a cancellation token that will never be canceled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// or:&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Some method signatures take both a &lt;code&gt;CancellationToken&lt;/code&gt; and a timeout value as separate parameters. I don’t recommend this for your own code; this is mainly done in the BCL to enable more efficient p/Invokes of methods that take timeout parameters. Unless you’re also p/Invoking APIs that take timeout parameters, I recommend just taking a single &lt;code&gt;CancellationToken&lt;/code&gt; which can represent &lt;em&gt;any&lt;/em&gt; kind of cancellation.&lt;/p&gt;

&lt;p&gt;By taking a &lt;code&gt;CancellationToken&lt;/code&gt; parameter, a method is implicitly claiming that it may respond to cancellation. Technically, this is “may respond”, not “must respond”. In some cases (like interface implementations), a &lt;code&gt;CancellationToken&lt;/code&gt; argument may be ignored. So the presence of a &lt;code&gt;CancellationToken&lt;/code&gt; parameter does not necessarily mean the code &lt;em&gt;must&lt;/em&gt; support cancellation, but it &lt;em&gt;might&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-cancellation-contract-response&quot;&gt;The Cancellation Contract: Response&lt;/h2&gt;

&lt;p&gt;As noted above, when cancellation is requested, the responding code may cancel whatever it is doing, or it may not. Even if it &lt;em&gt;attempts&lt;/em&gt; to cancel, there is usually a race condition and the method may actually complete before the cancellation request can be honored. The cancellation contract handles this by having canceled code throw &lt;code&gt;OperationCanceledException&lt;/code&gt; when the cancellation is observed and has actually canceled some work. If the cancellation request is ignored or if it arrives too late and the work is finished anyway, then the method returns normally without throwing &lt;code&gt;OperationCanceledException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The standard “90% case” code handles this implicitly; if &lt;code&gt;DoFirstStepAsync&lt;/code&gt; or &lt;code&gt;DoSecondStepAsync&lt;/code&gt; throw &lt;code&gt;OperationCanceledException&lt;/code&gt;, then that exception is also propagated out of &lt;code&gt;DoSomethingAsync&lt;/code&gt;. No change to the “90% case” code is necessary:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intermediateValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoFirstStepAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSecondStepAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intermediateValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;alert alert-danger&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-exclamation-triangle fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;There are a lot of code examples out there that just silently return early when cancellation is requested. Please do not do this; it’s a violation of the cancellation contract! When the responding code just returns early, the calling code cannot know whether its cancellation request was honored or ignored.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;exception-to-the-90-case&quot;&gt;Exception to the “90% Case”&lt;/h2&gt;

&lt;p&gt;The “90% case” just takes a &lt;code&gt;CancellationToken&lt;/code&gt; parameter and passes it down. There’s one notable exception to this rule: you shouldn’t pass down &lt;code&gt;CancellationToken&lt;/code&gt;s to &lt;code&gt;Task.Run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The reason is that (IMO) the semantics are confusing. A lot of developers pass a delegate and a &lt;code&gt;CancellationToken&lt;/code&gt; to &lt;code&gt;Task.Run&lt;/code&gt; and expect the delegate to be cancelled when the token is cancelled, but that’s not what happens. The &lt;code&gt;CancellationToken&lt;/code&gt; passed to &lt;code&gt;Task.Run&lt;/code&gt; just cancels the &lt;em&gt;scheduling&lt;/em&gt; of the delegate to the thread pool; once that delegate starts running (which happens pretty much immediately), that cancellation token is ignored.&lt;/p&gt;

&lt;p&gt;To put it in example code, this is what many developers write, incorrectly expecting that &lt;code&gt;// Do something&lt;/code&gt; will be canceled after it starts:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Do something, ignoring cancellationToken&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By never passing the &lt;code&gt;CancellationToken&lt;/code&gt; to &lt;code&gt;Task.Run&lt;/code&gt; (which is ignored anyway unless there’s serious thread pool contention or the token is &lt;em&gt;already&lt;/em&gt; cancelled), we make it clearer that the delegate &lt;em&gt;itself&lt;/em&gt; has to respond to the token:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomethingAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Do something&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// The IDE is telling me cancellationToken is unused,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//    so this delegate code better use it.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2022/02/cancellation-1-overview.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2022/02/cancellation-1-overview.html</guid>
      </item>
    
      <item>
        <title>Asynchronous Messaging, Part 5: Miscellaneous Considerations</title>
        <description>&lt;p&gt;This entry in my asynchronous messaging series is kind of a grab bag of miscellaneous topics. I don’t really have enough to say on these to make them their own posts, but some are too important to drop completely. So, here we go!&lt;/p&gt;

&lt;h2 id=&quot;poison--dead-letter-queues&quot;&gt;Poison / Dead Letter Queues&lt;/h2&gt;

&lt;p&gt;When designing your system, you need to decide how to handle queue messages that insist on failing to process. Usually, you plan for some kind of “dead letter queue” to hold these “poison” messages, and then set up alerting or something on that queue. Many cloud queue/worker systems will automatically do this for you: after a certain number of retries, the problematic message is removed from the regular queue and sent to a poison queue instead.&lt;/p&gt;

&lt;p&gt;Just don’t forget to set up alerting on those poison queues!&lt;/p&gt;

&lt;h2 id=&quot;versioning&quot;&gt;Versioning&lt;/h2&gt;

&lt;p&gt;When I design asynchronous messaging systems, I tend to treat the queued messages as a kind of Data Transfer Object (DTO). These messages act as a bridge between two processes: the HTTP application and the backend processor.&lt;/p&gt;

&lt;p&gt;Just like the rest of the system, the DTOs will change over time, and it’s best to be prepared for that. Unlike an HTTP stack, there’s no versioning possible in the URL or in a header. I tend to prefer versioning in the queue name itself, but you could also embed versions in the DTOs themselves. Generally, “storage DTOs” like these only require a single version number (i.e., they only have a major version, not a minor/patch version); this is because you explicitly &lt;em&gt;don’t&lt;/em&gt; want an older consumer to process newer queue messages.&lt;/p&gt;

&lt;h2 id=&quot;mix-and-match&quot;&gt;Mix and Match&lt;/h2&gt;

&lt;p&gt;I’ve pointed out that the cloud queue solutions work out of the box with the cloud backend processor solutions from the same company, including automatic scaling. But you don’t &lt;em&gt;have&lt;/em&gt; to use the same provider for each part of your asynchronous messaging architecture. It’s entirely possible to, e.g., scale Azure Functions based off a RabbitMQ, or wire up a Google Cloud hosted Docker backend to an Amazon SQS queue. Sometimes there are extra costs when crossing cloud providers, and sometimes you have to write a plugin so that your backend will use your kind of queue for its scaling; but it’s certainly possible to mix and match.&lt;/p&gt;

&lt;h2 id=&quot;all-in-one&quot;&gt;All-In-One&lt;/h2&gt;

&lt;p&gt;And then there is the other side: some solutions are all-in-one, complete solutions for asynchronous messaging. Examples of all-in-one solutions are &lt;a href=&quot;https://www.hangfire.io/&quot;&gt;Hangfire&lt;/a&gt; (.NET) and &lt;a href=&quot;https://github.com/collectiveidea/delayed_job&quot;&gt;Delayed Job&lt;/a&gt; (Ruby). Their all-in-one nature means they are easier to set up, but inevitably also means they are less flexible. There are also some very serious considerations you need to look into before adopting an all-in-one solution; what the developers of that solution created may be very different than what your application needs.&lt;/p&gt;

&lt;p&gt;Specifically, you need to look into:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Does it use a durable queue? If not, I would not even consider it. As a corollary, anything that uses Redis as a queue should not be used in its default configuration, including some very popular solutions such as Sidekiq (Ruby) and Bull (NodeJS). If you do wish to use Redis-based message queues, then you should configure Redis to be durable by telling it to write an Append Only File &lt;em&gt;and&lt;/em&gt; telling it to sync that file on every command. Both Hangfire and Delayed Job use a database as a queue, which is &lt;em&gt;just ok&lt;/em&gt; (assuming you already have a database in your architecture), but not &lt;em&gt;ideal&lt;/em&gt; (now your database server has to deal with all the queue messages as well as its normal data).&lt;/li&gt;
  &lt;li&gt;How are jobs serialized - is the serialization backwards-compatible when your library is updated? As an example of this, until recently (early 2019), Hangfire &lt;em&gt;did not support rolling upgrades&lt;/em&gt; due to the way they serialized jobs. Before that time, Hangfire-based applications had to shut down completely before rolling out a Hangfire upgrade, and if a rollback was necessary, they had to shut down completely before doing the rollback, too. Ouch!&lt;/li&gt;
  &lt;li&gt;How are jobs serialized - how much can the “runner” code change? My experience here is more with Hangfire: .NET is pretty specific when it comes to serializing method delegates, and even something like adding a parameter (with a default argument) can cause a failure. Any change like that now requires &lt;em&gt;two&lt;/em&gt; updates instead of one: the first will add the new overload, and once the old jobs have all completed, a second update can roll out to remove the old overload. I’m not as familiar with Delayed Jobs; Ruby is a more dynamic language, so it may not have this problem.&lt;/li&gt;
  &lt;li&gt;How are errors handled? Most all-in-one solutions will automatically retry, but if the job message insists on failing, then it has to do something else with it. By default, Hangfire will leave those job messages in a “failed” state (and it’s up to you to build some kind of notification on that), whereas Delayed Job will &lt;em&gt;delete&lt;/em&gt; those jobs (!).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In conclusion, caveat emptor. Don’t just slap an all-in-one solution into your architecture; a well-thought-out, proper asynchronous messaging solution is almost always the better choice.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2021/02/asynchronous-messaging-5-miscellaneous-considerations.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2021/02/asynchronous-messaging-5-miscellaneous-considerations.html</guid>
      </item>
    
      <item>
        <title>Asynchronous Messaging, Part 4: Retrieve Results</title>
        <description>&lt;p&gt;So far in this series, we’ve covered how asynchronous messaging can be implemented with a durable queue and a backend service. Those are the most necessary components of the solution, but another piece is sometimes necessary.&lt;/p&gt;

&lt;p&gt;Many times, it’s the desire to “return early” or “fire and forget” that start developers down the path of exogenous code and asynchronous messaging. Sometimes the client, as the originator of the request, wants to get the results of the long-running background operation.&lt;/p&gt;

&lt;h2 id=&quot;no-results-necessary&quot;&gt;No Results Necessary&lt;/h2&gt;

&lt;p&gt;Before looking into delivering results, it’s important to note that there are many scenarios that do not require explicitly sending results.&lt;/p&gt;

&lt;p&gt;One common case for long-running operations is sending an email. In cases like these, the email itself &lt;em&gt;is&lt;/em&gt; the actual result of the operation. So, there is no need for the original client to get a notification that the email has actually been sent; the email itself is the result.&lt;/p&gt;

&lt;p&gt;Another case that doesn’t need explicit results is when the human end-user will poll. Usually in this kind of scenario, some kind of status is exposed in the normal UI, and the end user will see the results sooner or later. Even the most non-technical end-users know how to refresh the page when they are looking for updates to occur.&lt;/p&gt;

&lt;p&gt;So, the first question to ask is whether retrieving results is actually necessary. In my experience, most asynchronous messaging solutions do not require explicitly retrieving results.&lt;/p&gt;

&lt;h2 id=&quot;polling&quot;&gt;Polling&lt;/h2&gt;

&lt;p&gt;If the client does need to detect the results of the asynchronous operation, then it can poll a “status” endpoint until the results are available, and then pull the final result (or error, if the operation failed). Most HTTP APIs these days are REST-based, so I’ll describe here the most common approaches for implementing polling for asynchronous messaging completion.&lt;/p&gt;

&lt;p&gt;Unfortunately, there’s a wide variety of implementations for this kind of pattern. The one thing everyone agrees with is that the initial status response code should be &lt;code&gt;202 Accepted&lt;/code&gt;. This is for the call that initiates the asynchronous messaging, so the HTTP application should put its message into a durable queue and then return &lt;code&gt;202 Accepted&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The HTTP application should also return some kind of information that allows the client to poll for completion. This is usually done via some kind of “status” URI. The &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3.3&quot;&gt;actual standard&lt;/a&gt; just says “The representation sent with this response ought to describe the request’s current status and point to (or embed) a status monitor that can provide the user with an estimate of when the request will be fulfilled.” This is very open-ended, and this is where the implementations begin to diverge. One option is to return the status URI in the body of the &lt;code&gt;202 Accepted&lt;/code&gt; (e.g., as a JSON property). Another option is to return the status URI in the &lt;code&gt;Location&lt;/code&gt; header of the response.&lt;/p&gt;

&lt;p&gt;Once the client has the status URI, it can begin calling that URI periodically for updates on that asynchronous operation. Again, implementations diverge on the details here, depending on whether the status is considered a “resource” in REST terms. As long as the operation is not complete, some implementations return &lt;code&gt;200 OK&lt;/code&gt; with some kind of “incomplete” indicator in the body; other implementations return &lt;code&gt;202 Accepted&lt;/code&gt; from the status URI. The server can also optionally include a “percentage complete” indicator in its response body, and/or a &lt;code&gt;Retry-After&lt;/code&gt; header if it has an estimated time of completion (to discourage over-eager polling).&lt;/p&gt;

&lt;p&gt;If the operation completes with an error, then the status URI can either return &lt;code&gt;200 OK&lt;/code&gt; with the “error” in the response body (if treating the status as a “resource”), or it can return an appropriate error code (&lt;code&gt;4xx&lt;/code&gt;/&lt;code&gt;5xx&lt;/code&gt;) with optional error details in the response body. If the operation completes successfully, then the status URI should return &lt;code&gt;303 See Other&lt;/code&gt; with the &lt;code&gt;Location&lt;/code&gt; header set to the resource that was updated/modified by the asynchronous message. Alternatively, the status API could also return &lt;code&gt;200 OK&lt;/code&gt;, &lt;code&gt;201 Created&lt;/code&gt;, or &lt;code&gt;204 No Content&lt;/code&gt; to indicate successful completion.&lt;/p&gt;

&lt;p&gt;As you can see, there’s considerable variation in how exactly asynchronous messaging is implemented from a REST API standpoint. There are no standards or widespread accepted pattern. I recommend not losing too much sleep over which one is “right”, and just documenting clearly which approach you take for your API.&lt;/p&gt;

&lt;p&gt;One final note: in order to retrieve results, your backend processing service must be sharing its progress with the HTTP application. At the very least, the HTTP application serving the status URIs must be able to know when the asynchronous message has been processed. A more complete implementation may need to share a &lt;code&gt;Location&lt;/code&gt; URI, error details, progress percentage, and/or estimated time to completion. These “in progress details” could be in a shared database (and often are placed there), but it’s not necessary that they be durable. It’s fine to store in-progress details in an in-memory structure such as a shared cache.&lt;/p&gt;

&lt;h2 id=&quot;notification&quot;&gt;Notification&lt;/h2&gt;

&lt;p&gt;Polling (whether done by the user or by the client) is a perfectly valid solution for most cases. In some cases, however, your clients need to know &lt;em&gt;immediately&lt;/em&gt; whenever the message has been processed. This is rare, but not unheard of. In this case, you wouldn’t want to use polling, where you’d have to tradeoff how quickly your client sees the completion against the number of wasted requests all saying “is it done yet?”&lt;/p&gt;

&lt;p&gt;In the case where you need realtime notification of completion, you should use a server-initiated notification system. These days, that pretty much always means WebSockets (or SignalR), although old-school solutions like long polling or even server-side events (SSE) are still around, too. All of these solutions enable an HTTP application to push a message to an already-connected client. In this case, the common approach is to have the backend processing service connect to the HTTP application via some kind of bus (e.g., it could connect to a SignalR hub), and then send a message over that bus directly to the HTTP application, which notifies its clients that the processing is complete.&lt;/p&gt;

&lt;p&gt;This is a fine approach, and only has one caveat: when a system’s architecture becomes complex enough to introduce asynchronous messaging, then that system is also positioned to be prepared to scale out. The bus connecting the HTTP application instances to the background processing instances needs to be ready for scaling. Some systems (e.g., SignalR) are not set up to scale by default. If I was adding asynchronous messaging to a system and we needed to use SignalR for realtime notifications, then I would set it up with a scalable backplane immediately.&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2021/01/asynchronous-messaging-4-retrieve-results.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2021/01/asynchronous-messaging-4-retrieve-results.html</guid>
      </item>
    
      <item>
        <title>Asynchronous Messaging, Part 3: Backend Service</title>
        <description>&lt;p&gt;The proper solution for request-extrinsic code is asynchronous messaging, which has two primary parts: a durable queue and a backend service. Today I’m going to discuss the backend service.&lt;/p&gt;

&lt;h2 id=&quot;backend-services&quot;&gt;Backend Services&lt;/h2&gt;

&lt;p&gt;The purpose of the background service is to process the queue messages. When the HTTP application wants to return before the processing is complete, it queues a message to the durable queue and then returns. The background service is the other side of that pipe; the HTTP application is the producer putting messages into the queue, and the background service is the consumer retrieving messages from the queue and processing them.&lt;/p&gt;

&lt;p&gt;I usually recommend that the background service is &lt;strong&gt;independent&lt;/strong&gt; from the HTTP application, but it doesn’t strictly have to be.&lt;/p&gt;

&lt;p&gt;One reason for having a separate service is that they can be scaled independently; if they were in the same application, then scaling out the HTTP application means the background service is also scaled out. Independent services means each one can be scaled as needed: the HTTP application scales based on HTTP requests, and the background service scales based on queue messages.&lt;/p&gt;

&lt;p&gt;Another reason for having a separate service is that having an independent service &lt;em&gt;requires&lt;/em&gt; the use of an external queue. If the background service is in the same process as the HTTP application, it’s not obvious that an in-memory queue is an inappropriate solution, and a future code maintainer may change the queue to be in-memory as an attempted optimization.&lt;/p&gt;

&lt;p&gt;A final reason for having an independent background service is that the background service itself affects how the HTTP application can be shut down. The background service consists entirely of request-extrinsic code, so special care must be taken to allow proper shutdowns.&lt;/p&gt;

&lt;p&gt;For all these reasons, I recommend that background services are separate, independent services. But regardless of whether the background service is independent or sharing the same process as the HTTP application, it must process its messages idempotently.&lt;/p&gt;

&lt;h2 id=&quot;idempotency&quot;&gt;Idempotency&lt;/h2&gt;

&lt;p&gt;An operation is &lt;strong&gt;idempotent&lt;/strong&gt; if it can be applied multiple times and produce the same result each time. In other words, once an idempotent operation has been applied, then future applications of that same operation are noops. Ideally, the background service should process its messages idempotently.&lt;/p&gt;

&lt;p&gt;This is necessary just due to the realities of durable queues. The CAP theorem has all the details, but the takeaway for modern distributed computing is that durable queues will deliver their durable messages &lt;strong&gt;at least once&lt;/strong&gt;. This means that the background service may get the same message more than once.&lt;/p&gt;

&lt;p&gt;Ideally, you should try to structure your processing code so that receiving the same message more than once is a noop. Sometimes this means capturing more of the “state” of the system at the time the message is queued, and including that additional state in the queue messages.&lt;/p&gt;

&lt;p&gt;Sometimes idempotency just isn’t possible. Or easy, at least. In that case, you can use &lt;strong&gt;de-duplication&lt;/strong&gt; to explicitly check for duplicate messages over a reasonable time period. Idempotent processing is best, and de-duplication is a reasonable fallback.&lt;/p&gt;

&lt;h2 id=&quot;examples-of-backend-services&quot;&gt;Examples of Backend Services&lt;/h2&gt;

&lt;p&gt;Just like durable queues, my go-to solutions for backend services are cloud solutions, specifically Functions as a Service (FaaS). FaaS is a perfect fit for background services, and even more so if you’re using a cloud-based durable queue. All the major cloud providers have built-in support for combining their durable queues with their FaaS offerings. This includes scaling logic: each cloud provider will auto-scale FaaS consumers based on their queue messages.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://azure.microsoft.com/en-us/services/storage/queues/?WT.mc_id=DT-MVP-5000058&quot;&gt;Azure Storage Queues&lt;/a&gt; pair with &lt;a href=&quot;https://azure.microsoft.com/en-us/services/functions/?WT.mc_id=DT-MVP-5000058&quot;&gt;Azure Functions&lt;/a&gt;; &lt;a href=&quot;https://aws.amazon.com/sqs/&quot;&gt;Amazon Simple Queue Service (SQS) queues&lt;/a&gt; pair with &lt;a href=&quot;https://aws.amazon.com/lambda/&quot;&gt;AWS Lambdas&lt;/a&gt;; and &lt;a href=&quot;https://cloud.google.com/tasks&quot;&gt;Google Cloud Task queues&lt;/a&gt; pair with &lt;a href=&quot;https://cloud.google.com/functions&quot;&gt;Google Cloud Functions&lt;/a&gt;. Cloud pairs such as these are the easiest way to implement a full asynchronous messaging solution.&lt;/p&gt;

&lt;p&gt;For on-premises solutions, one natural approach is a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/services/services?WT.mc_id=DT-MVP-5000058&quot;&gt;Win32 service&lt;/a&gt; (if on Windows) or a &lt;a href=&quot;https://www.man7.org/linux/man-pages/man7/daemon.7.html&quot;&gt;Linux daemon&lt;/a&gt; (if on Linux). These are background services that run all the time the server machine is on, regardless of whether a user is logged in. They are headless processes that do not permit direct user interaction. This makes background services a natural choice for both HTTP applications and the background processing services.&lt;/p&gt;

&lt;p&gt;Another possible solution is a regular Console application wrapped in a Docker container. Docker containers can be deployed either on-premise or in the cloud. This is a similar approach to the Win32 service / Linux daemon approach, but has better support for scaling out. Right now, Docker orchestrators are getting more support for scaling based on queue messages; setting up an autoscaler based on RabbitMQ messages is tedious but possible.&lt;/p&gt;

&lt;p&gt;The final - and least recommended solution - is to have the backend service run as a part of the HTTP application. As noted above, there are a few disadvantages to this approach: it cannot scale independently, the resulting architecture implies that an in-memory queue is acceptable, and it complicates shutdown handling. However, some teams do choose this option in spite of the drawbacks. When putting the backend service in the same process as the HTTP application, the host &lt;em&gt;must&lt;/em&gt; be notified of the background work, or else work may be lost. Also, any “upstream” systems like HTTP proxies, load balancers, and deployment scripts may require changes so that they are also aware of the non-standard shutdown rules.&lt;/p&gt;

&lt;div class=&quot;alert alert-info&quot;&gt;
  &lt;p&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;ASP.NET-specific:&lt;/strong&gt; In ASP.NET Core, use &lt;code&gt;IHostedService&lt;/code&gt;, or &lt;code&gt;IHostApplicationLifetime&lt;/code&gt; to detect and block HTTP application shutdown. &lt;code&gt;BackgroundService&lt;/code&gt; can also be used, but be aware that work may be lost if the host shutdown times out. In ASP.NET pre-Core, use &lt;code&gt;HostingEnvironment.QueueBackgroundWorkItem&lt;/code&gt; or &lt;code&gt;IRegisteredObject&lt;/code&gt;. Again, this is for the &lt;em&gt;least recommended solution&lt;/em&gt; and you’ll &lt;em&gt;also&lt;/em&gt; need to consider the impact on proxies, load balancers, and deployment systems. A far better solution would be to make the backend processing service independent (in its own process), and not change the HTTP shutdown rules at all.&lt;/p&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2021/01/asynchronous-messaging-3-backend-processor.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2021/01/asynchronous-messaging-3-backend-processor.html</guid>
      </item>
    
      <item>
        <title>Asynchronous Messaging, Part 2: Durable Queues</title>
        <description>&lt;p&gt;Last time I concluded that the proper solution for request-extrinsic code is asynchronous messaging, which has two primary parts: a durable queue and a backend service. Today I’m going to discuss durable queues.&lt;/p&gt;

&lt;h2 id=&quot;the-definition-of-durable&quot;&gt;The Definition of “Durable”&lt;/h2&gt;

&lt;p&gt;When I suggest the asynchronous messaging solution, I try to use the term “durable” or “reliable”, and the emphasis is on the “durable” in “durable queue”. But what do “durable” or “reliable” really mean? There’s a range of meanings, from what I would consider “minimum viable” to “paranoid”.&lt;/p&gt;

&lt;p&gt;A durable queue must &lt;em&gt;at least&lt;/em&gt; write the new item to disk when it is placed into the queue. In other words, a durable queue is one that stores &lt;strong&gt;durable messages&lt;/strong&gt;. This is the minimum viable behavior for a durable queue: messages must survive shutdowns. Asynchronous messaging &lt;em&gt;must&lt;/em&gt; use a queue whose messages survive shutdown. This is good enough for many (most?) applications.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;more&lt;/em&gt; durable (or more reliable) queue would be one that writes to &lt;em&gt;multiple&lt;/em&gt; disks. This allows the messages to also survive a single disk failure. An even more durable queue would be one that writes to disks on multiple &lt;em&gt;servers&lt;/em&gt;; this allows the messages to survive a complete server failure. Finally, the most paranoid durable queues write to multiple servers in distinct geographical locations; this allows the message to survive the destruction of an entire data center. Most applications do not require that level of durability.&lt;/p&gt;

&lt;p&gt;But it’s important to note that the minimum acceptable reliability is writing to disk. In-memory queues are &lt;em&gt;not&lt;/em&gt; reliable enough for asynchronous messaging; this includes &lt;code&gt;Queue&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Channel&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;BlockingCollection&amp;lt;T&amp;gt;&lt;/code&gt;, the three most common in-memory queues. When I say they are not “reliable”, I don’t mean that they can’t be used as in-memory queues; they’re perfectly fine for that scenario. However, since their messages are not durable (i.e., will not survive shutdown), they do not provide sufficient reliability for use with asynchronous messaging.&lt;/p&gt;

&lt;h2 id=&quot;the-problem-with-in-memory-queues&quot;&gt;The Problem with In-Memory Queues&lt;/h2&gt;

&lt;p&gt;I’m going to dive into this in a bit of detail, because this is a common point of confusion. I’ve defined “durable” as meaning at least “on disk”, and I’ve used the reasoning that “asynchronous messages must survive shutdown”. This section will go into more detail of the reasoning behind this restriction.&lt;/p&gt;

&lt;p&gt;I think it’s easiest to understand this by contemplating one question: “When is it safe for an HTTP service to shut down?”&lt;/p&gt;

&lt;p&gt;The HTTP protocol is ubiquitous; it’s used by all kinds of APIs and web services. And there’s a seemingly endless number of conventions and standards built on top of HTTP. With all these details and abstractions, sometimes one critical truth is forgotten: &lt;strong&gt;the HTTP protocol is a request/response protocol&lt;/strong&gt;. In other words, for every request there is exactly one response. From the HTTP service’s perspective, a request arrives, and then some time later the response is sent and that request is completed.&lt;/p&gt;

&lt;p&gt;Back to that question: “When is it safe for an HTTP service to shut down?” The easiest possible answer is “when a response for each request has been sent.” Or to word the same idea a different way: “when there are no more outstanding requests.”&lt;/p&gt;

&lt;p&gt;This is such a natural answer to the question that &lt;em&gt;every&lt;/em&gt; HTTP server has this as its default answer. It doesn’t matter if you’re on ASP.NET, Node.js, Ruby on Rails, … &lt;em&gt;Every&lt;/em&gt; HTTP server framework keeps track of how many outstanding requests it has, and considers itself “safe to shut down” when that number reaches zero. This also holds true for load balancers and proxies: “When is it safe to remove this HTTP server from my list?” - “When it has no more requests waiting for responses.” It doesn’t matter if you’re using nginx, HAProxy, Kubernetes’ apiserver proxy, … &lt;em&gt;Every&lt;/em&gt; HTTP proxy application keeps track of the number of outstanding requests, and considers HTTP servers “done” when they have sent out responses for all of their requests.&lt;/p&gt;

&lt;p&gt;This is why request-extrinsic code is dangerous: all of this default behavior is suddenly wrong. The HTTP service says it’s safe to shut down when it’s not safe to shut down; all the proxies and load balancers say it’s safe to take that machine out of rotation when it’s not.&lt;/p&gt;

&lt;h3 id=&quot;shutdowns-are-normal&quot;&gt;Shutdowns Are Normal&lt;/h3&gt;

&lt;p&gt;Often developers react to this by trying to force alternative solutions. All HTTP server frameworks answer “When is it safe to shut down?” with “When there are no more outstanding requests” &lt;em&gt;by default&lt;/em&gt;, but many of them allow overriding that default so the application itself can answer “It’s only safe to shut down when I say it’s safe to shut down.”&lt;/p&gt;

&lt;p&gt;One of the problems with trying to force that alternative solution is that it only changes the answer at the HTTP service level; proxies and load balancers &lt;em&gt;also&lt;/em&gt; need to have their default logic changed (assuming that changing the default is even possible). Even if you get that working, there’s an unending maintenance problem: your HTTP server farm now handles shutdowns &lt;em&gt;completely differently&lt;/em&gt; than all other HTTP server farms.&lt;/p&gt;

&lt;p&gt;When developers begin down this path, it is usually because the developer wants to keep their HTTP application running indefinitely. And this is a major misunderstanding: in reality, systems are more resilient if servers do &lt;em&gt;not&lt;/em&gt; run indefinitely. In fact, shutdowns are &lt;em&gt;normal&lt;/em&gt;, and we need to accept shutdowns as a normal part of life.&lt;/p&gt;

&lt;p&gt;One example is rolling updates. When a new version of an HTTP application is developed, it needs to replace the old versions of that application. The normal way to do this is via rolling updates: for each server, the upstream proxy will stop forwarding new requests, wait until the service has no more outstanding requests, shut it down, install the update, start it up, and start forwarding new requests. Shutdowns are necessary to perform rolling updates.&lt;/p&gt;

&lt;p&gt;Another example is applying operating system or runtime patches. This is similar to rolling updates, but in this case it is the lower layers that is being updated, so it’s machine-wide. The same steps apply, though: stop forwarding new requests to all services on that machine, wait until the machine has no outstanding requests, shut down all the services, install the patches (rebooting if necessary), start up all the services, and start forwarding new requests. This kind of shutdown occurs regularly, even for HTTP services that are not in active development.&lt;/p&gt;

&lt;p&gt;A final example is that some frameworks and host processes just do periodic application restarts just to keep things clean. For example, Apache’s &lt;code&gt;MaxConnectionsPerChild&lt;/code&gt; or IIS’s &lt;code&gt;periodicRestart&lt;/code&gt; can recycle child processes periodically. This is primarily useful for managing memory leaks in applications, frameworks, and/or libraries. Apache no longer recycles by default, but IIS still does. Again, this is based on the number of outstanding requests: the server will recycle its child application when it has no outstanding requests.&lt;/p&gt;

&lt;p&gt;The reasonable conclusion is that &lt;em&gt;shutdowns are normal&lt;/em&gt;. All HTTP applications must work correctly when shutdowns occur. Corollary: All software that assumes it will never shut down is inherently buggy.&lt;/p&gt;

&lt;p&gt;Finally, we return to what “durable” means. In-memory queues cannot survive shutdowns. Therefore, “minimum acceptable reliability” means that the queue of work survives shutdowns, which are normal and common.&lt;/p&gt;

&lt;h2 id=&quot;examples-of-durable-queues&quot;&gt;Examples of Durable Queues&lt;/h2&gt;

&lt;p&gt;I tend to prefer cloud queues whenever possible, because the cloud provider manages them, they scale really well, and they give you knobs for controlling how paranoid you want your durability to be.&lt;/p&gt;

&lt;p&gt;For this reason, my top go-tos for durable queues are &lt;a href=&quot;https://azure.microsoft.com/en-us/services/storage/queues/?WT.mc_id=DT-MVP-5000058&quot;&gt;Azure Storage Queue&lt;/a&gt;, &lt;a href=&quot;https://aws.amazon.com/sqs/&quot;&gt;Amazon Simple Queue Service (SQS)&lt;/a&gt;, and &lt;a href=&quot;https://cloud.google.com/tasks&quot;&gt;Google Cloud Tasks&lt;/a&gt;. I’m most familiar with Azure’s queueing, though I have also used Amazon’s in production systems. All cloud queueing systems provide durable queues that can scale out automatically.&lt;/p&gt;

&lt;p&gt;As much as I like cloud solutions, on-premises queueing systems are perfectly viable. It’s not possible to get the same scaling capabilities as a cloud solution, but you can get lower latencies. The most common on-premises durable queues these days are &lt;a href=&quot;https://www.rabbitmq.com/&quot;&gt;RabbitMQ&lt;/a&gt; and &lt;a href=&quot;https://kafka.apache.org/documentation/&quot;&gt;Kafka&lt;/a&gt;. I’ve also used &lt;a href=&quot;https://www.ibm.com/products/mq&quot;&gt;IBM MQ&lt;/a&gt; (called WebSphere MQ at the time). For older Windows systems, &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/desktop/msmq/ms711472(v=vs.85)?WT.mc_id=DT-MVP-5000058&quot;&gt;Microsoft Message Queueing (MSMQ)&lt;/a&gt; was common, though that is no longer recommended these days. Note that some on-premises queueing solutions do not use durable messages by default, so some configuration is necessary to make them actually durable (I’m looking at you, &lt;a href=&quot;https://www.rabbitmq.com/queues.html#durability&quot;&gt;RabbitMQ&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;There are other solutions for both cloud and on-premises. The ones mentioned here are just ones I’ve had experience with, and which appear to be the most common.&lt;/p&gt;

&lt;h3 id=&quot;database-as-a-durable-queue&quot;&gt;Database As a Durable Queue&lt;/h3&gt;

&lt;p&gt;One other solution that is sometimes used is an actual database. Usually, this needs to be a database that guarantees ACID. Some NoSql databases can also be used as durable queues, as long as they actually have durable writes; but be aware that some NoSql databases can lose writes, in which case they do not qualify as durable queues. In my experience, most databases used as durable queues are fully ACID (i.e., transactional).&lt;/p&gt;

&lt;p&gt;Using an ACID database as a durable queue allows you to use the Outbox Pattern. When a service wants to publish a message &lt;em&gt;if and only if&lt;/em&gt; a particular database transaction succeeds, then it writes that message to the database &lt;em&gt;as part of that transaction&lt;/em&gt;. It can’t publish the message before doing the database update, because the database update may fail; and it can’t publish the message after doing the database update, because if there’s some problem reaching the durable queue then the message wouldn’t be published. So, by using the database itself as a durable queue, then the service guarantees that the message will be published if and only if the database update takes place.&lt;/p&gt;

&lt;p&gt;The Outbox Pattern gets its name because there’s usually a separate “outbox” table that just holds messages that are published. It’s possible to have the queue consumer read the outbox table directly, but a more common solution is to have the outbox table just act as temporary storage for messages on their way to another durable queue - usually one that is used by the rest of the application, e.g., a cloud queue or on-premises durable queue. In that case, the publishing service (or another service) has a polling job that reads the messages from the outbox table, sends them to the durable queue, and then deletes those messages from the outbox table. This provides an at-least-once delivery of the messages stored in the outbox table.&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
        <link>https://blog.stephencleary.com/2021/01/asynchronous-messaging-2-durable-queues.html</link>
        <guid isPermaLink="true">https://blog.stephencleary.com/2021/01/asynchronous-messaging-2-durable-queues.html</guid>
      </item>
    
  </channel>
</rss>
